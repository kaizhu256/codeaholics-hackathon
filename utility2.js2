/* MODULE_BEGIN { "actionList": ["trim"], "file": ".gitignore" } */
*.bak
*.log
*.min.*
*.pid
*.swp
*decrypted*
.DS_Store
._*
.build
.env
.git*
.hg
.install
.lock-wscript
.npmrc
.src
.svn
.vim
.wafpickle-*
CVS
Procfile
README.*
artifacts
bower_components
node_modules
log
logs
public/utility2
tmp
/* MODULE_END */



/* MODULE_BEGIN { "actionList": ["trim"], "file": ".install/git-config" } */
[branch "gh-pages"]
  remote = origin
  merge = refs/heads/gh-pages
[branch "master"]
  remote = origin
  merge = refs/heads/master
[branch "unstable"]
  remote = origin
  merge = refs/heads/unstable
[core]
  bare = false
  filemode = true
  ignorecase = true
  logallrefupdates = true
  repositoryformatversion = 0
[receive]
  denyCurrentBranch = warn
[remote "heroku"]
  fetch = +refs/heads/*:refs/remotes/heroku/*
  url = git@heroku.com:codeaholics-hackathon-unstable.git
[remote "origin"]
  fetch = +refs/heads/*:refs/remotes/origin/*
  url = git@github.com:kaizhu256/codeaholics-hackathon.git
/* MODULE_END */



/* MODULE_BEGIN { "actionList": ["trim"], "file": ".install/git-ssh.sh" } */
#!/bin/sh
## this script overrides the default key file used by ssh
exec ssh -i $GIT_SSH_KEY_FILE -o CheckHostIP=no -o StrictHostKeychecking=no -- "$@"
/* MODULE_END */



/* MODULE_BEGIN { "actionList": ["lint"], "file": "/public/utility2/utility2-external.browser.js" } */
/*jslint browser: true, indent: 2, maxerr: 8, node: true, nomen: true, regexp: true*/
/*global global, required, state, utility2*/
(function initModule() {
  'use strict';
  if (typeof window === 'object') {
    window.global = window.global || window;
  }
  /* init required object */
  global.required = global.required || {};
  return {
    cache: true,
    cachePrefix: '/rollup',
    postProcessing: function (content) {
      return content
        /* mime.types */
        .replace(
          (/(\n\/\* MODULE_BEGIN .*\/mime.types \*\/\n)([\S\s]+?)(\n\/\* MODULE_END \*\/\n)/g),
          function (_, header, content, footer) {
            utility2.nop(_);
            return header + '(function () { required.mime = { lookupDict: { /*'
              + content.replace((/^(\w\S+)\s+(\w.*)$/gm), function (_, value, keyList) {
                utility2.nop(_);
                return '*/' + keyList.replace((/\S+/g), function (key) {
                  return '"' + key + '":"' + value + '",';
                }) + '/*';
              }) + '*/ } }; }());' + footer;
          }
        )
        /* nodejs */
        .replace(
          (/(\n\/\* MODULE_BEGIN https:\/\/raw\.githubusercontent\.com\/joyent\/node\/master\/lib\/(\w+)\.js \*\/\n[\S\s]+?\n\/\* MODULE_END \*\/\n)/g),
          '(function () { var module = {}, exports = module.exports = {},'
            + 'process = global.process || {};'
            + 'require = function (module) { return required[module] };'
            + '$1'
            + 'required.$2 = module.exports; }());'
        );
    },
    urlList: [
      /* mime.types */
      'https://svn.apache.org/repos/asf/httpd/httpd/trunk/docs/conf/mime.types',
      /* nodejs */
      'https://raw.githubusercontent.com/joyent/node/master/lib/util.js',
      'https://raw.githubusercontent.com/joyent/node/master/lib/path.js',
      'https://raw.githubusercontent.com/joyent/node/master/lib/punycode.js',
      'https://raw.githubusercontent.com/joyent/node/master/lib/querystring.js',
      'https://raw.githubusercontent.com/joyent/node/master/lib/url.js'
    ]
  };
}());
/* MODULE_END */



/* MODULE_BEGIN { "actionList": ["lint"], "file": "/public/utility2/utility2-external.nodejs.js" } */
/*jslint browser: true, indent: 2, maxerr: 8, node: true, nomen: true, regexp: true*/
/*global global, required, state, utility2*/
(function initModule() {
  'use strict';
  if (typeof window === 'object') {
    window.global = window.global || window;
  }
  global.required = global.required || {};
  return {
    cache: true,
    cachePrefix: '/rollup',
    postProcessing: function (content) {
      return content
        /* colors */
        .replace(
          (/(\n\/\* MODULE_BEGIN .*\/colors\.js \*\/\n[\S\s]+?\n\/\* MODULE_END \*\/\n)/g),
          '(function () { var module = {}, exports = module.exports = {}; $1'
            + 'required.colors = exports;'
            + '}());'
        )
        /* connect logger */
        .replace(
          (/(\n\/\* MODULE_BEGIN .*\/expressjs\/morgan\/master\/index\.js \*\/\n[\S\s]+?\n\/\* MODULE_END \*\/\n)/g),
          '(function () { var module = {}, exports = module.exports = {};'
            + 'require = function (module) { return function (arg) { return arg; }; };'
            + '$1'
            + 'required.connect_logger = exports;'
            + '}());'
        )
        /* csslint */
        .replace(
          (/(\n\/\* MODULE_BEGIN .*\/csslint\.js \*\/\n[\S\s]+?\n\/\* MODULE_END \*\/\n)/g),
          '(function () { var module = {}, exports = module.exports = {}; $1'
            + 'required.csslint = CSSLint;'
            + '}());'
        )
        /* cssmin */
        .replace(
          (/(\n\/\* MODULE_BEGIN .*\/cssmin\.js \*\/\n[\S\s]+?\n\/\* MODULE_END \*\/\n)/g),
          '(function () { var module = {}, exports = module.exports = {}; $1'
            + 'required.cssmin = cssmin; }());'
        )
        /* jslint */
        .replace(
          (/(\n\/\* MODULE_BEGIN .*\/jslint\.js \*\/\n[\S\s]+?\n\/\* MODULE_END \*\/\n)/g),
          '(function () { var module = {}, exports = module.exports = {}; $1'
            + 'required.jslint = JSLINT; }());'
        )
        /* mime.types */
        .replace(
          (/(\n\/\* MODULE_BEGIN .*\/mime\.types \*\/\n)([\S\s]+?)(\n\/\* MODULE_END \*\/\n)/g),
          function (_, header, content, footer) {
            utility2.nop(_);
            return header + '(function () { required.mime = { lookupDict: { /*'
              + content.replace((/^(\w\S+)\s+(\w.*)$/gm), function (_, value, keyList) {
                utility2.nop(_);
                return '*/' + keyList.replace((/\S+/g), function (key) {
                  return '"' + key + '":"' + value + '",';
                }) + '/*';
              }) + '*/ } }; }());' + footer;
          }
        )
        /* nodejs */
        .replace(
          (/(\n\/\* MODULE_BEGIN https:\/\/raw\.githubusercontent\.com\/joyent\/node\/master\/lib\/(\w+)\.js \*\/\n[\S\s]+?\n\/\* MODULE_END \*\/\n)/g),
          '(function () { var module = {}, exports = module.exports = {},'
            + 'process = global.process || {};'
            + 'require = function (module) { return required[module] };'
            + '$1'
            + 'required.$2 = module.exports; }());'
        )
        /* uglify-js */
        .replace(
          (/(\n\/\* MODULE_BEGIN https:\/\/raw\.githubusercontent\.com\/mishoo\/UglifyJS2\/master\/lib\/utils\.js \*\/\n[\S\s]+\n\/\* MODULE_BEGIN https:\/\/raw\.githubusercontent\.com\/mishoo\/UglifyJS2\/master\/lib\/mozilla-ast\.js \*\/\n[\S\s]+?\n\/\* MODULE_END \*\/\n)/g),
          '(function () { var module = {}, exports = module.exports = {}; $1'
            + 'required.uglifyjs = { parse: parse, Compressor: Compressor, OutputStream: OutputStream }; }());'
        );
    },
    urlList: [
      /* colors */
      'https://raw.githubusercontent.com/Marak/colors.js/master/colors.js',
      /* connect logger */
      'https://raw.githubusercontent.com/expressjs/morgan/master/index.js',
      /* csslint */
      'https://raw.githubusercontent.com/stubbornella/csslint/master/release/csslint.js',
      /* cssmin */
      'https://raw.githubusercontent.com/jbleuzen/node-cssmin/master/cssmin.js',
      /* jslint */
      'https://raw.githubusercontent.com/douglascrockford/JSLint/master/jslint.js',
      /* mime.types */
      'http://svn.apache.org/repos/asf/httpd/httpd/trunk/docs/conf/mime.types',
      /* nodejs */
      'https://raw.githubusercontent.com/joyent/node/master/lib/util.js',
      'https://raw.githubusercontent.com/joyent/node/master/lib/path.js',
      'https://raw.githubusercontent.com/joyent/node/master/lib/punycode.js',
      'https://raw.githubusercontent.com/joyent/node/master/lib/querystring.js',
      'https://raw.githubusercontent.com/joyent/node/master/lib/url.js',
      /* uglifyjs */
      'https://raw.githubusercontent.com/mishoo/UglifyJS2/master/lib/utils.js',
      'https://raw.githubusercontent.com/mishoo/UglifyJS2/master/lib/ast.js',
      'https://raw.githubusercontent.com/mishoo/UglifyJS2/master/lib/parse.js',
      'https://raw.githubusercontent.com/mishoo/UglifyJS2/master/lib/transform.js',
      'https://raw.githubusercontent.com/mishoo/UglifyJS2/master/lib/scope.js',
      'https://raw.githubusercontent.com/mishoo/UglifyJS2/master/lib/output.js',
      'https://raw.githubusercontent.com/mishoo/UglifyJS2/master/lib/compress.js',
      'https://raw.githubusercontent.com/mishoo/UglifyJS2/master/lib/sourcemap.js',
      'https://raw.githubusercontent.com/mishoo/UglifyJS2/master/lib/mozilla-ast.js'
    ]
  };
}());
/* MODULE_END */



/* MODULE_BEGIN { "actionList": ["trim"], "file": "/public/utility2/utility2-loading.svg" } */
<svg xmlns="http://www.w3.org/2000/svg" width="16" height="8">
<g transform="translate(8, 4)">
  <rect x="-8" y="-4" width="5" height="8">
    <animateTransform id="a" attributeName="transform" type="scale" from="1,0.5" to="1" dur="0.4s" begin="0;b.end"/>
    <animate attributeName="fill" from="#eee" to="#888" dur="0.4s" begin="0;b.end"/>
    <animateTransform id="b" attributeName="transform" type="scale" from="1" to="1,0.5" dur="0.4s" begin="a.end"/>
    <animate attributeName="fill" from="#888" to="#eee" dur="0.4s" begin="a.end"/>
  </rect>
  <rect x="-2" y="-4" width="4" height="8">
    <animateTransform id="c" attributeName="transform" type="scale" from="1,0.5" to="1" dur="0.4s" begin="0.1s;d.end"/>
    <animate attributeName="fill" from="#eee" to="#888" dur="0.4s" begin="0.1s;d.end"/>
    <animateTransform id="d" begin="c.end" attributeName="transform" type="scale" to="1,0.5" from="1" dur="0.4s"/>
    <animate attributeName="fill" from="#888" to="#eee" dur="0.4s" begin="c.end"/>
  </rect>
  <rect x="3" y="-4" width="5" height="8">
    <animateTransform id="e" attributeName="transform" type="scale" from="1,0.5" to="1" dur="0.4s" begin="0.2s;f.end"/>
    <animate attributeName="fill" from="#eee" to="#888" dur="0.4s" begin="0.2s;f.end"/>
    <animateTransform id="f" attributeName="transform" type="scale" from="1" to="1,0.5" dur="0.4s" begin="e.end"/>
    <animate attributeName="fill" from="#888" to="#eee" dur="0.4s" begin="e.end"/>
  </rect>
</g>
</svg>
/* MODULE_END */



/* MODULE_BEGIN { "actionList": ["lint"], "file": ".install/saucelabs-test-platforms-list.json" } */
{
  "platformsList": [
    [
      ["linux", "android", "4.3"],
      ["linux", "googlechrome", "34"],
      ["linux", "firefox", "29"],
      ["linux", "opera", "12"],
      ["osx 10.9", "ipad", "7.1"],
      ["osx 10.9", "iphone", "7.1"],
      ["osx 10.9", "safari", "7"],
      ["windows 8.1", "iexplore", "11"]
    ]
  ],
  "stateOverride": {
    "timeoutDefault": 200000
  },
  "url": "https://utility2.herokuapp.com/test/test.html#modeTest=1&timeoutDefault={{timeoutDefault}}"
}
/* MODULE_END */



/* MODULE_BEGIN { "actionList": ["trim"], "file": "Procfile" } */
web: npm start --utility2-server-port=$PORT
/* MODULE_END */



/* MODULE_BEGIN { "actionList": ["trim"], "file": "/public/utility2/testReport.html.template" } */
<style>
.testReportPlatformDiv {
  border: 1px solid;
  border-radius: 5px;
  font-family: arial;
  margin: 20px 0 0 0;
  padding: 0 10px 10px 10px;
  text-align: left;
}
.testReportPlatformPre {
  background-color: #fdd;
  border: 1px;
  border-radius: 0 0 5px 5px;
  border-top-style: solid;
  margin-bottom: 0px;
  padding: 10px;
}
.testReportPlatformPreHidden {
  display: none;
}
.testReportPlatformSpan {
  display: inline-block;
  width: 7em;
}
.testReportPlatformTable {
  border: 1px;
  border-top-style: solid;
  text-align: left;
  width: 100%;
}
.testReportSummaryDiv {
  background-color: #bfb;
}
.testReportSummarySpan {
  display: inline-block;
  width: 6.5em;
}
tr:nth-child(odd).testReportPlatformTr {
  background-color: #bfb;
}
.testReportTestFailed {
  background-color: #f99;
}
.testReportTestPending {
  background-color: #99f;
}
.testReportTestSkipped {
  background-color: #bbb;
}
</style>

<div class="testReportPlatformDiv testReportSummaryDiv">
<h2>test report summary</h2>
<h4>
  <span class="testReportSummarySpan">build date</span>- {{date}}<br>
  <span class="testReportSummarySpan">build id</span>- {{CI_BUILD_NUMBER}}<br>
  <span class="testReportSummarySpan">repo url</span>- <a href="{{GITHUB_REPO_URL_HREF}}">{{GITHUB_REPO_URL}}</a><br>
  <span class="testReportSummarySpan">commit info</span>- {{CI_COMMIT_INFO}}<br>
</h4>
<table class="testReportPlatformTable">
<thead><tr>
  <th>total time</th>
  <th>total tests failed</th>
  <th>total tests skipped</th>
  <th>total tests passed</th>
  <th>platforms failed</th>
  <th>platforms passed</th>
</tr></thead>
<tbody><tr>
  <td>{{totalTime}} ms</td>
  <td class="{{testsFailedClass}}">{{testsFailed}}</td>
  <td class="{{testsSkippedClass}}">{{testsSkipped}}</td>
  <td class="testReportTestPassed">{{testsPassed}}</td>
  <td class="{{testsFailedClass}}">{{platformsFailed}}</td>
  <td class="testReportTestPassed">{{platformsPassed}}</td>
</tr></tbody>
</table>
</div>

{{@testPlatformList}}
<div class="testReportPlatformDiv">
<h4>
  {{testPlatformNumber}}. {{name}}<br>
  <!-- <span class="testReportPlatformSpan">{{testPlatformNumber}}</span><br> -->
  <!-- <span class="testReportPlatformSpan">platform</span>- {{name}}<br> -->
  <span class="testReportPlatformSpan">total time</span>- {{totalTime}} ms<br>
  <span class="testReportPlatformSpan">tests failed</span>- {{testsFailed}}<br>
  <span class="testReportPlatformSpan">tests skipped</span>- {{testsSkipped}}<br>
  <span class="testReportPlatformSpan">tests passed</span>- {{testsPassed}}<br>
</h4>
<table class="testReportPlatformTable">
<thead><tr>
  <th>#</th>
  <th>time</th>
  <th>status</th>
  <th>test case</th>
</tr></thead>
<tbody>
{{@testCaseList}}
<tr class="testReportPlatformTr">
  <td>{{testCaseNumber}}</td>
  <td>{{time}} ms</td>
  <td class="{{testReportTestStatusClass}}">{{status}}</td>
  <td>{{name}}</td>
</tr>
{{/@testCaseList}}
</tbody>
</table>
<pre class="{{testReportPlatformPreClass}}">
{{@errorMessageList}}
{{errorMessage}}
{{/@errorMessageList}}
</pre>
</div>
{{/@testPlatformList}}
/* MODULE_END */



/* MODULE_BEGIN { "actionList": ["trim"], "file": "/test/test.html" } */
<!DOCTYPE html><html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
<title>{{name}} test page</title>
<style>
body {
  font-family: arial;
}
#testRunButton {
  background-color: #37b;
  border: 0px solid;
  border-radius: 4px;
  color: #fff;
  cursor: pointer;
  font-size: medium;
  padding: 5px 10px;
}
</style>
<link href="/public/utility2/utility2.css" rel="stylesheet"/>
</head>
<body>
<h1>{{name}} test page</h1>
<div id="ajaxProgressDiv"></div>
<button id="testRunButton">run tests</button>
<div id="testReportDiv"></div>
<script>
  /* enable tests for utility2 namespace */
  window.state = { testModuleDict: {{testModuleDict}} };
  document.getElementById('testRunButton').addEventListener('click', function () {
    location.hash = '#modeTest=1';
    location.reload();
  });
</script>
<script src="/public/utility2/utility2-external.browser.rollup.min.js"></script>
<script src="/public/utility2/utility2.js"></script>
<script src="{{testScript}}"></script>
</body>
</html>
/* MODULE_END */



/* MODULE_BEGIN { "actionList": ["base64Decode"], "file": "/test/test.png" } */
iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAIAAACQkWg2AAAC1klEQVQozwXByXLTZgAA4H+VLFmSZcuy4zh24zjOVpYCKaUZ
DkmAMsPAkRmGd+ilL9FzH6EvQKfTQ3sptAdgIDQs06YsgTjExIu8xZK16//5PljbyFKEMII5QwIIi6Fye+tu48sLh3tPX735
u8Nxo7zRazdf7z8XKSjl61jPiTEDvhf1R9M60n6obN7auNEwZr/aunapl16yvG7gOQJynAHBCYMBUmekmUpG1IRzQvGn8cp2
ZjHMKz737T8f0Xr14hH6viVWR/0A26ohJ5yhlEARBKqmfOfpRT/2/n0tjl20NI9Xa/D9URD72Ore7EtprI4mnut6JPCSCLDS
F/mqZ0hBwYMC+PkPeu8hDN2g+YFBzDAgA2dpWdzHsVSgWFSJNXKSk3CTle/bw18HB497TSsOirlZQzEnw54zHuap/EH0dlHX
D0I4u6YxhK5Eerttt5JpBRNAAIe8SDM3F9a35s8MOq3u4f7zc/Se0ht8GmN9Tk5CzhGcnSlDyCkEZsnU89mEgmfT1m5w9A8Z
/2Id66Z0rARZMUUilxORepCs12o7uvTm4DCnZaqlwmHHGnX7uqp/06i1Hd8A8p2z5789tUE4Q4RwaohiVr6UW4Cum8JxRknJ
hJW01KqpVwxztVQUFE2OjCdPXmCtKGGM3TBJFLA5t1xQ0oaerRXKhqKtludOLS5SQhCnfzXf3d/7z3MTDESEMWCMT2G0mDb6
nZ6q6aqcThjrDKwwisKYPzh++6D3/9py49rFbUIgAoAIGA0teyd1MC9IR+1282NLliTbc9pDCymZnXEzwUym6VyxglEKR34c
+fFk6HZOnLpZyEkSRJhCQiUSTr2W12+PxmkubX99dXLiEBbyhLLYTzBCA8Hes7un59YxwSxO3jbfB35w/cLmj+9cgfBdu/7b
ymXCIWMOjxhLC8J1sbqQq/btyWDcn1qj0PUzM+bH4UidMtOe/B7bL9Wlz0MZYXZdLOnfAAAAAElFTkSuQmCC
/* MODULE_END */



/* MODULE_BEGIN { "actionList": ["lint"], "file": "/test/modeAjaxOffline/https%3A%2F%2Fapi.github.com%2Frepos%2Fkaizhu256%2Fblob%2Fcontents%2Ftest%2F_Branch_default_test.json%23DELETE" } */
{
  "commit": {
    "html_url": "https://github.com/kaizhu256/blob/commit/da39a3ee5e6b4b0d3255bfef95601890afd80709",
    "message": "[skip ci] delete /test/_Branch_default_test.json",
    "parents": [
      {
        "html_url": "https://github.com/kaizhu256/blob/commit/da39a3ee5e6b4b0d3255bfef95601890afd80709",
        "sha": "da39a3ee5e6b4b0d3255bfef95601890afd80709",
        "url": "https://api.github.com/repos/kaizhu256/blob/git/commits/da39a3ee5e6b4b0d3255bfef95601890afd80709"
      }
    ],
    "sha": "da39a3ee5e6b4b0d3255bfef95601890afd80709",
    "tree": {
      "sha": "da39a3ee5e6b4b0d3255bfef95601890afd80709",
      "url": "https://api.github.com/repos/kaizhu256/blob/git/trees/da39a3ee5e6b4b0d3255bfef95601890afd80709"
    },
    "url": "https://api.github.com/repos/kaizhu256/blob/git/commits/da39a3ee5e6b4b0d3255bfef95601890afd80709"
  },
  "content": null
}
/* MODULE_END */



/* MODULE_BEGIN { "actionList": ["lint"], "file": "/test/modeAjaxOffline/https%3A%2F%2Fapi.github.com%2Frepos%2Fkaizhu256%2Fblob%2Fcontents%2Ftest%2F_Branch_default_test.json%23PUT" } */
{
  "commit": {
    "html_url": "https://github.com/kaizhu256/blob/commit/da39a3ee5e6b4b0d3255bfef95601890afd80709",
    "message": "[skip ci] create /test/_Branch_default_test.json",
    "parents": [
      {
        "html_url": "https://github.com/kaizhu256/blob/commit/da39a3ee5e6b4b0d3255bfef95601890afd80709",
        "sha": "da39a3ee5e6b4b0d3255bfef95601890afd80709",
        "url": "https://api.github.com/repos/kaizhu256/blob/git/commits/da39a3ee5e6b4b0d3255bfef95601890afd80709"
      }
    ],
    "sha": "da39a3ee5e6b4b0d3255bfef95601890afd80709",
    "tree": {
      "sha": "da39a3ee5e6b4b0d3255bfef95601890afd80709",
      "url": "https://api.github.com/repos/kaizhu256/blob/git/trees/da39a3ee5e6b4b0d3255bfef95601890afd80709"
    },
    "url": "https://api.github.com/repos/kaizhu256/blob/git/commits/da39a3ee5e6b4b0d3255bfef95601890afd80709"
  },
  "content": {
    "_links": {
      "git": "https://api.github.com/repos/kaizhu256/blob/git/blobs/da39a3ee5e6b4b0d3255bfef95601890afd80709",
      "html": "https://github.com/kaizhu256/blob/blob/unstable/test/_Branch_default_test.json",
      "self": "https://api.github.com/repos/kaizhu256/blob/contents/test/_Branch_default_test.json?ref=unstable"
    },
    "git_url": "https://api.github.com/repos/kaizhu256/blob/git/blobs/da39a3ee5e6b4b0d3255bfef95601890afd80709",
    "html_url": "https://github.com/kaizhu256/blob/blob/unstable/test/_Branch_default_test.json",
    "name": "_Branch_default_test.json",
    "path": "test/_Branch_default_test.json",
    "sha": "da39a3ee5e6b4b0d3255bfef95601890afd80709",
    "size": 23,
    "type": "file",
    "url": "https://api.github.com/repos/kaizhu256/blob/contents/test/_Branch_default_test.json?ref=unstable"
  }
}
/* MODULE_END */



/* MODULE_BEGIN { "actionList": ["lint"], "file": "/test/modeAjaxOffline/https%3A%2F%2Fapi.github.com%2Frepos%2Fkaizhu256%2Fblob%2Fcontents%2Ftest%3Fref%3Dunstable%23GET" } */
[
  {
    "_links": {
      "git": "https://api.github.com/repos/kaizhu256/blob/git/blobs/da39a3ee5e6b4b0d3255bfef95601890afd80709",
      "html": "https://github.com/kaizhu256/blob/blob/unstable/test/_Branch_default_test.json",
      "self": "https://api.github.com/repos/kaizhu256/blob/contents/test/_Branch_default_test.json?ref=unstable"
    },
    "git_url": "https://api.github.com/repos/kaizhu256/blob/git/blobs/da39a3ee5e6b4b0d3255bfef95601890afd80709",
    "html_url": "https://github.com/kaizhu256/blob/blob/unstable/test/_Branch_default_test.json",
    "name": "_Branch_default_test.json",
    "path": "test/_Branch_default_test.json",
    "sha": "da39a3ee5e6b4b0d3255bfef95601890afd80709",
    "size": 23,
    "type": "file",
    "url": "https://api.github.com/repos/kaizhu256/blob/contents/test/_Branch_default_test.json?ref=unstable"
  }
]
/* MODULE_END */



/* MODULE_BEGIN { "actionList": ["trim"], "file": "/test/modeAjaxOffline/https%3A%2F%2Fimg.shields.io%2Fbadge%2Fcoverage-100.0%25-00dd00.svg%3Fstyle%3Dflat%23GET" } */
<svg xmlns="http://www.w3.org/2000/svg" width="117" height="20">
<linearGradient id="a" x2="0" y2="100%">
  <stop offset="0" stop-color="#fff" stop-opacity=".1"/>
  <stop offset=".1" stop-color="#fff" stop-opacity=".1"/>
  <stop offset=".9" stop-color="#fff" stop-opacity=".1"/>
  <stop offset="1" stop-color="#fff" stop-opacity=".1"/>
</linearGradient>
<path fill="#555" d="M0 0h117v20h-117z"/>
<path fill="#0d0" d="M63 0h54v20h-54zM63 0h4v20h-4z"/>
<path fill="url(#a)" d="M0 0h117v20h-117z"/>
<g fill="#fff" text-anchor="middle" font-family="arial" font-size="11">
  <text x="32.5" y="13">coverage</text><text x="89" y="13">100.0%</text>
</g>
</svg>
/* MODULE_END */



/* MODULE_BEGIN { "actionList": ["trim"], "file": "/test/modeAjaxOffline/https%3A%2F%2Fimg.shields.io%2Fbadge%2Ftests_failed-999-dd0000.svg%3Fstyle%3Dflat%23GET" } */
<svg xmlns="http://www.w3.org/2000/svg" width="103" height="20">
<linearGradient id="a" x2="0" y2="100%">
  <stop offset="0" stop-color="#fff" stop-opacity=".1"/>
  <stop offset=".1" stop-color="#fff" stop-opacity=".1"/>
  <stop offset=".9" stop-color="#fff" stop-opacity=".1"/>
  <stop offset="1" stop-color="#fff" stop-opacity=".1"/>
</linearGradient><path fill="#555" d="M0 0h103v20h-103z"/>
<path fill="#d00" d="M72 0h31v20h-31zM72 0h4v20h-4z"/>
<path fill="url(#a)" d="M0 0h103v20h-103z"/>
<g fill="#fff" text-anchor="middle" font-family="arial" font-size="11">
  <text x="37" y="13">tests failed</text><text x="86.5" y="13">999</text>
</g>
</svg>
/* MODULE_END */



/* MODULE_BEGIN { "actionList": ["lint"], "file": "/test/modeAjaxOffline/https%3A%2F%2Fsaucelabs.com%2Frest%2Fv1%2Futility2-kaizhu256%2Fjs-tests%23POST" } */
{
  "js tests": [
    "064df78366ea4b25b32f88878c9d7aa4",
    "1e5ed949711545bd952456ac37479ada"
  ]
}
/* MODULE_END */



/* MODULE_BEGIN { "actionList": ["lint"], "file": "/test/modeAjaxOffline/https%3A%2F%2Fsaucelabs.com%2Frest%2Fv1%2Futility2-kaizhu256%2Fjs-tests%2Fstatus%23POST" } */
{
  "completed": true,
  "js tests": [
    {
      "id": "064df78366ea4b25b32f88878c9d7aa4",
      "job_id": "1a7aec8ef0c64165bcde1230e213ad44",
      "platform": [
        "Linux",
        "googlechrome",
        "34"
      ],
      "result": {
        "coverage": null,
        "failed": 0,
        "testCallbackId": null,
        "testReport": {
          "errorMessageList": [],
          "testPlatformList": [
            {
              "name": "browser - saucelabs googlechrome",
              "testCaseList": [
                {
                  "module": "utility2.moduleSaucelabsBrowser",
                  "name": "_saucelabs_default_test",
                  "time":1
                }
              ],
              "totalTime": 2
            }
          ],
          "totalTime": 3
        }
      },
      "url": "http://saucelabs.com/jobs/ff737d47e03e47bfb45100a45e4b5ca5"
    },
    {
      "id": "1e5ed949711545bd952456ac37479ada",
      "job_id": "1a7aec8ef0c64165bcde1230e213ad45",
      "platform": [
        "Linux",
        "firefox",
        "29"
      ],
      "result": {
        "coverage": null,
        "failed": 0,
        "testCallbackId": null,
        "testReport": {
          "errorMessageList": [],
          "testPlatformList": [
            {
              "name": "browser - saucelabs firefox",
              "testCaseList": [
                {
                  "module": "utility2.moduleSaucelabsBrowser",
                  "name": "_saucelabs_default_test",
                  "time":1
                }
              ],
              "totalTime": 2
            }
          ],
          "totalTime": 3

        }
      },
      "url": "http://saucelabs.com/jobs/ff737d47e03e47bfb45100a45e4b5ca6"
    }
  ]
}
/* MODULE_END */



/* MODULE_BEGIN { "actionList": ["lint"], "file": "/test/test.css" } */
aa {
  background-image:url(
"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQAQMAAAAlPW0iAAAABlBMVEUAAAD///+l2Z/dAAAAM0lEQVR4nGP4/5/h/1+G/58ZDrAz3D/McH8yw83NDDeNGe4Ug9C9zwz3gVLMDA/A6P9/AFGGFyjOXZtQAAAAAElFTkSuQmCC"
  );
}
bb {
  background-image:url("test.png");
}
/* MODULE_END */



/* MODULE_BEGIN { "actionList": ["lint"], "file": "/test/test.js" } */
/*global console*/
console.log('hello test');
/* MODULE_END */



/* MODULE_BEGIN { "actionList": ["trim"], "file": "/test/test.json" } */
"hello test"
/* MODULE_END */



/* MODULE_BEGIN { "actionList": ["lint"], "file": "/public/utility2/utility2.css" } */
.ajaxProgressBarDiv {
  animation: 2s linear 0s normal none infinite ajaxProgressBarDivAnimation;
  -o-animation: 2s linear 0s normal none infinite ajaxProgressBarDivAnimation;
  -webkit-animation: 2s linear 0s normal none infinite ajaxProgressBarDivAnimation;
  background-image: linear-gradient(
    45deg,rgba(255,255,255,.25) 25%,
    transparent 25%,
    transparent 50%,
    rgba(255,255,255,.25) 50%,
    rgba(255,255,255,.25) 75%,
    transparent 75%,
    transparent
  );
  background-size: 40px 40px;
  color: #fff;
  font-family: arial;
  font-size: 12px;
  padding: 2px 0 2px 0;
  text-align: center;
  transition: width .5s ease;
  width: 0%;
}
.ajaxProgressBarDivError {
  background-color: #d33;
}
.ajaxProgressBarDivLoading {
  background-color: #37b;
}
.ajaxProgressBarDivSuccess {
  background-color: #3b3;
}
#ajaxProgressDiv {
  background-color: #fff;
  border: 1px solid;
  cursor: pointer;
  display: none;
  left: 50%;
  margin: 0 0 0 -50px;
  padding: 5px 5px 5px 5px;
  position: fixed;
  top: 49%;
  width: 100px;
  z-index: 9999;
}
@keyframes ajaxProgressBarDivAnimation {
  from { background-position: 40px 0; }
  to { background-position: 0 0; }
}
@-o-keyframes ajaxProgressBarDivAnimation {
  from { background-position: 40px 0; }
  to { background-position: 0 0; }
}
@-webkit-keyframes ajaxProgressBarDivAnimation {
  from { background-position: 40px 0; }
  to { background-position: 0 0; }
}
/* MODULE_END */



/* MODULE_BEGIN { "actionList": ["lint"], "file": "/public/utility2/utility2-test.js" } */
/* MODULE_END */



/* MODULE_BEGIN { "actionList": ["lint", "eval"], "file": "/public/utility2/utility2.js" } */
/*jslint browser: true, indent: 2, maxerr: 8, node: true, nomen: true, regexp: true, stupid: true*/
/*global global, required, state, utility2*/
(function moduleInitShared() {
  /*
    this shared module inits utility2
  */
  'use strict';
  var local;
  local = {

    _name: 'utility2.moduleInitShared',

    _init: function () {
      var tmp;
      /* init global object */
      if (typeof window === 'object') {
        window.global = window;
      }
      /* init utility2 object */
      global.utility2 = global.required.utility2 = global.utility2 || {};
      local.setDefault(global, {
        /* global state object */
        state: {
          /* list of test-generated errors to be ignored */
          onEventErrorDefaultIgnoreList: [],
          /* dict of cached files */
          fsWatchDict: {},
          /* dict of server-side test callbacks to be triggered by the browser */
          testCallbackDict: {},
          /* default timeout */
          timeoutDefault: 120000
        },
        /* global utility2 object */
        utility2: {
          assert: local.assert,
          deferCallback: local.deferCallback,
          initLocal: local.initLocal,
          onEventErrorDefault: local.onEventErrorDefault,
          onEventTimeout: local.onEventTimeout,
          setDefault: local.setDefault
        }
      });
      /* init debug print */
      global[['debug', 'Print'].join('')] = utility2._zxqjDp = function (arg) {
        /*
          this internal function is used for tmp debugging,
          and jslint will nag you to remove it if used
        */
        console.error('\n\n\ndebug' + 'Print');
        console.error.apply(console, arguments);
        console.error();
        /* return arg for inspection */
        return arg;
      };
      /* init global.onEventError debug callback */
      global.onEventError = utility2.onEventErrorDefault;
      /* init utility2 for nodejs */
      if (state.modeNodejs) {
        /* require utility2-external */
        if (process.argv.indexOf('--mode-cli=npmInstall') < 0) {
          required.utility2_external = required.utility2_external
            || utility2.require('./public/utility2/utility2-external.nodejs.rollup.js');
        }
      }
      /* init utility2 for browser */
      if (global.document
          && document.body
          && global.location
          && typeof location.hash === 'string'
          && global.window) {
        state.modeBrowser = true;
        state.modeCoverageInit = 2;
        /* set browser test mode */
        state.modeTest = state.modeTest || (/\bmodeTest=\w/).test(location.hash);
        /* set browser timeoutDefault */
        tmp = (/\btimeoutDefault=(\d+)\b/).exec(location.hash);
        state.timeoutDefault = tmp ? Number(tmp[1]) : state.timeoutDefault;
      }
      /* init utility2.untilReadyUtility2 */
      utility2.untilReadyUtility2 = utility2.untilReadyUtility2 || function (onEventError) {
        /*
          this function defers the onEventError callback until utility2 is ready
        */
        utility2.deferCallback('untilReadyUtility2', 'defer', onEventError);
      };
      /* init utility2.readyUtility2 */
      utility2.readyUtility2 = utility2.readyUtility2 || local.untilReady(function (error) {
        /*
          this function is called to indicate that a component of utility2 is ready
        */
        utility2.deferCallback('untilReadyUtility2', 'ready', error);
      });
      /* utility2 ready */
      utility2.readyUtility2.remaining += 1;
      setTimeout(utility2.readyUtility2);
      /* init module */
      utility2.initLocal(local);
      /* assert state.timeoutDefault is a positive, finite number */
      setTimeout(function () {
        utility2.assert(
          0 < state.timeoutDefault && state.timeoutDefault < Infinity,
          'invalid state.timeoutDefault ' + state.timeoutDefault
        );
      });
    },

    _initOnce: function () {
      /* init utility2.error object */
      utility2.error = utility2.error || new Error('utility2 error');
      /* init state.testReport */
      state.testReport = state.testReport || {};
      utility2.testReportMerge(state.testReport);
      /* init browser */
      local._initOnceBrowser(global);
    },

    _initOnceBrowser: function (global2) {
      /*
        this function runs browser-side initializations
      */
      if (!state.modeBrowser) {
        return;
      }
      /* mock required.colors */
      required.colors = required.colors || {};
      [
        'black', 'blackBG', 'blue', 'blueBG', 'bold',
        'cyan', 'cyanBG',
        'green', 'greenBG', 'grey', 'greyBG',
        'inverse', 'italic',
        'magenta', 'magentaBG',
        'rainbow', 'red', 'redBG',
        'strikethrough', 'stripColors',
        'underline',
        'white', 'whiteBG',
        'yellow', 'yellowBG',
        'zebra'
      ].forEach(function (color) {
        required.colors[color] = required.colors[color] || utility2.echo;
      });
      /* save erver-side testCallbackId */
      state.testCallbackId = utility2.urlParamsGet(global2.location.search).testCallbackId;
      /* init testReportDiv element */
      state.testReportDiv = global2.document.getElementById('testReportDiv');
      if (state.testReportDiv) {
        utility2.readyUtility2.remaining += 1;
        setTimeout(function () {
          /* get testReport html template */
          utility2.ajax({
            url: '/public/utility2/testReport.html.template'
          }, function (error, data) {
            state.fsWatchDict['/public/utility2/testReport.html.template'] = {
              contentBrowser: data
            };
            utility2.readyUtility2(error);
            utility2.clearCallSetInterval('testReportDivUpdate', function () {
              state.testReportDiv.innerHTML
                = utility2.testReportHtml(state.testReport);
            }, 1000, state.timeoutDefault);
          });
        });
      } else {
        state.testReportDiv = {};
      }
    },

    __initOnceBrowser_default_test: function (onEventError) {
      /*
        this function tests _initOnceBrowser's default handling behavior
      */
      var data, global2;
      utility2.testMock(onEventError, [
        [global, { required: { url: required.url }, state: {} }],
        [utility2, { deferCallback: utility2.callArg2 }]
      ], function (onEventError) {
        /* test browser mode disabed handling behavior */
        state.modeBrowser = false;
        local._initOnceBrowser({});
        data = utility2.jsonStringifyOrdered(global.state);
        /* validate state */
        utility2.assert(data === JSON.stringify({ modeBrowser: false }), data);
        /* test browser mode handling behavior */
        state.modeBrowser = true;
        global2 = {
          /* test state.testReportDiv disabled handling behavior */
          document: { getElementById: utility2.nop },
          location: { search: '' }
        };
        local._initOnceBrowser(global2);
        data = utility2.jsonStringifyOrdered(global.state);
        /* validate state */
        utility2.assert(data === JSON.stringify({
          modeBrowser: true,
          testCallbackId: undefined,
          testReportDiv: {}
        }), data);
        onEventError();
      });
    },

    callArg0: function (callback) {
      /*
        this function calls the callback in arg position 0
      */
      callback();
    },

    callArg1: function (_, callback) {
      /*
        this function calls the callback in arg position 1
      */
      utility2.nop(_);
      callback();
    },

    callArg2: function (_, __, callback) {
      /*
        this function calls the callback in arg position 2
      */
      utility2.nop(_, __);
      callback();
    },

    callError0: function (onEventError) {
      /*
        this function calls the onEventError callback in arg position 0 with an error object
      */
      onEventError(utility2.error);
    },

    callError1: function (_, onEventError) {
      /*
        this function calls the onEventError callback in arg position 1 with an error object
      */
      utility2.nop(_);
      onEventError(utility2.error);
    },

    callError2: function (_, __, onEventError) {
      /*
        this function calls the onEventError callback in arg position 2 with an error object
      */
      utility2.nop(_, __);
      onEventError(utility2.error);
    },

    _callX_default_test: function (onEventError) {
      /*
        this function tests callX's default handling behavior
      */
      utility2.callArg0(function (error) {
        /* assert no error occurred */
        utility2.assert(!error, error);
      });
      utility2.callArg1(null, function (error) {
        /* assert no error occurred */
        utility2.assert(!error, error);
      });
      utility2.callArg2(null, null, function (error) {
        /* assert no error occurred */
        utility2.assert(!error, error);
      });
      utility2.callError0(function (error) {
        /* assert error occurred */
        utility2.assert(error instanceof Error, error);
      });
      utility2.callError1(null, function (error) {
        /* assert error occurred */
        utility2.assert(error instanceof Error, error);
      });
      utility2.callError2(null, null, function (error) {
        /* assert error occurred */
        utility2.assert(error instanceof Error, error);
      });
      onEventError();
    },

    assert: function (passed, message) {
      /*
        this function throws an error if the assertion fails
      */
      if (!passed) {
        /* if message is an Error object, then get its stack trace */
        message = message instanceof Error
          ? utility2.errorStack(message)
          /* if message is a string, then leave it as is */
          : typeof message === 'string'
          ? message
          /* else JSON.stringify message */
          : utility2.jsonStringifyCircular(message);
        throw new Error('assertion error - ' + (message || 'undefined'));
      }
    },

    _assert_default_test: function (onEventError) {
      /*
        this function tests assert's default handling behavior
      */
      /* test assertion passed */
      utility2.assert(true, true);
      /* test assertion failed */
      utility2.tryCatch(function () {
        utility2.assert(false, undefined);
      }, function (error) {
        /* assert error occurred */
        utility2.assert(error instanceof Error, error);
      });
      /* test assertion failed with text message */
      utility2.tryCatch(function () {
        utility2.assert(false, '_assert_default_test');
      }, function (error) {
        /* assert error occurred */
        utility2.assert(error instanceof Error, error);
      });
      /* test assertion failed with error object */
      utility2.tryCatch(function () {
        utility2.assert(false, utility2.error);
      }, function (error) {
        /* assert error occurred */
        utility2.assert(error instanceof Error, error);
      });
      onEventError();
    },

    clearCallSetInterval: function (key, callback, interval, timeout) {
      /*
        this function
        1. clear old interval / timeout key
        2. run callback
        3. set interval key to callback
      */
      var dict;
      dict = state.clearCallSetIntervalDict = state.clearCallSetIntervalDict || {};
      dict[key] = dict[key] || {};
      /* 1. clear old interval / timeout key */
      clearInterval(dict[key].interval);
      clearTimeout(dict[key].timeout);
      /* set timeout for clearCallSetInterval */
      if (timeout) {
        dict[key].timeout = utility2.onEventTimeout(function (error) {
          utility2.clearCallSetInterval(key, 'clear');
          callback(error);
        }, timeout, key);
      }
      /* clear timer */
      if (callback === 'clear') {
        delete dict[key];
        return;
      }
      /* 2. call callback */
      callback();
      /* 3. set interval key to callback */
      if (dict[key]) {
        dict[key].interval = setInterval(callback, interval);
        return dict[key].interval;
      }
    },

    _clearCallSetInterval_synchronous_test: function (onEventError) {
      /*
        this function tests clearCallSetInterval's synchronous handling behavior
      */
      var ii, key;
      ii = 0;
      key = utility2.uuid4();
      utility2.clearCallSetInterval(key, function (error) {
        ii += 1;
        utility2.tryCatch(function () {
          /* assert no error occurred */
          utility2.assert(!error, error);
          utility2.clearCallSetInterval(key, 'clear');
          onEventError();
        }, onEventError);
      }, 1000);
      /* assert callback was called synchronously before setInterval */
      utility2.assert(ii === 1, ii);
    },

    _clearCallSetInterval_timeout_test: function (onEventError) {
      /*
        this function tests clearCallSetInterval's timeout handling behavior
      */
      var ii, onEventReady;
      ii = 0;
      onEventReady = utility2.untilReady(onEventError);
      [100, 500, 1000].forEach(function (timeout) {
        var key, time;
        key = utility2.uuid4();
        onEventReady.remaining += 1;
        time = Date.now();
        utility2.clearCallSetInterval(key, function (error) {
          ii += 1;
          utility2.tryCatch(function () {
            if (error) {
              /* assert error occurred */
              utility2.assert(error instanceof Error);
              /* assert error is timeout error */
              utility2.assert(error.code === 'ETIMEDOUT');
              time = Date.now() - time;
              /* assert time passed is greater than timeout */
              /* bug - ie and opera may timeout slightly earlier, so increase the timeout */
              utility2.assert(1.5 * time >= timeout, time);
              onEventReady();
            }
          }, onEventReady);
        }, 500, timeout);
      });
      /* test synchronous handling behavior */
      utility2.assert(ii === 3, ii);
    },

    _createTest: function (global, local2) {
      /*
        this function creates a _Test object
      */
      var self, testReport;
      self = new local._Test();
      self.global = global;
      self.local2 = local2;
      /* init testReport */
      testReport = self.global.state.testReport;
      utility2.testReportMerge(testReport);
      /* init testReport.totalTime */
      testReport.totalTime = testReport.totalTime || Date.now();
      /* init testReport.onEventReady */
      testReport.onEventReady = testReport.onEventReady || utility2.untilReady(function () {
        /* record time for testReport to run */
        testReport.totalTime = utility2.timeElapsed(testReport.totalTime);
        /* assert state.onEventErrorDefaultIgnoreList is empty */
        utility2.assert(!state.onEventErrorDefaultIgnoreList
          || state.onEventErrorDefaultIgnoreList.length === 0,
          state.onEventErrorDefaultIgnoreList);
        /* assert the following objects have no side-effect properties resulting from test */
        [
          utility2.callArg0, utility2.callArg1, utility2.callArg2,
          utility2.callError0, utility2.callError1, utility2.callError2
        ].forEach(function (obj) {
          utility2.assert(Object.keys(obj).length === 0, Object.keys(obj));
        });
        /* report test results */
        self.report();
      });
      return self;
    },

    _debug_print_default_test: function (onEventError) {
      /*
        this function tests debug print's default handling behavior
      */
      utility2.testMock(onEventError, [
        [console, { error: null }]
      ], function (onEventError) {
        var message;
        message = '';
        console.error = function (_) {
          message += (_ || '') + '\n';
        };
        utility2._zxqjDp('_debug_print_default_test');
        utility2.assert(
          message === '\n\n\ndebug' + 'Print\n_debug_print_default_test\n\n',
          message
        );
        onEventError();
      });
    },

    deferCallback: function (key, mode, callback) {
      /*
        this function defers the callback until ready
      */
      var self;
      self = state.deferCallbackDict = state.deferCallbackDict || {};
      self = self[key] = self[key] || { callbackList: [] };
      switch (mode) {
      case 'defer':
        /* optimization - fast callback if ready-state already triggered */
        if (self.modeReady) {
          callback(self.error);
          return;
        }
        /* slow deferred callback */
        self.callbackList.push(callback);
        break;
      case 'delete':
        delete state.deferCallbackDict[key];
        break;
      case 'ready':
        self.error = callback;
        self.modeReady = true;
        while (self.callbackList.length) {
          utility2.deferCallback(key, 'defer', self.callbackList.shift());
        }
        break;
      }
    },

    echo: function (arg) {
      return arg;
    },

    _echo_default_test: function (onEventError) {
      /*
      this function tests echo's default handling behavior
      */
      var data;
      data = utility2.echo('_echo_default_test');
      utility2.assert(data === '_echo_default_test', data);
      onEventError();
    },

    errorStack: function (error) {
      /*
        this function returns the error's stack or message attribute if possible
      */
      return error && (error.stack || error.message || error);
    },

    evalOnEventError: function (file, script, onEventError) {
      /*
        this function evals the script in a try-catch block with error handling,
        in the utility2 module context
      */
      if (file instanceof Error) {
        onEventError(file);
        return;
      }
      utility2.tryCatch(function () {
        /*jslint evil: true*/
        onEventError(null, state.modeNodejs
          /* eval in nodejs */
          ? required.vm.runInThisContext(script, file)
          /* eval in browser */
          : eval(script));
      }, onEventError);
    },

    _evalOnEventError_default_test: function (onEventError) {
      /*
        this function tests evalOnEventError's default handling behavior
      */
      /* test default handling behavior */
      utility2.evalOnEventError(
        '_evalOnEventError_default_test.js',
        '"_evalOnEventError_default_test"',
        function (error, data) {
          /* assert no error occurred */
          utility2.assert(!error, error);
          utility2.assert(data === '_evalOnEventError_default_test', data);
        }
      );
      /* test error handling behavior */
      utility2.evalOnEventError(utility2.error, null, function (error) {
        /* assert error occurred */
        utility2.assert(error instanceof Error, error);
      });
      /* test syntax error handling behavior */
      utility2.evalOnEventError(
        '_evalOnEventError_default_test.js',
        '_evalOnEventError_default_test',
        function (error) {
          /* assert error occurred */
          utility2.assert(error instanceof Error, error);
        }
      );
      onEventError();
    },

    initLocal: function (local2) {
      /*
        this function inits the module with the local object
      */
      var exports;
      /* assert local2._name */
      utility2.assert(local2._name, 'invalid local2._name ' + local2._name);
      /* module exports */
      exports = local2._name.split('.');
      exports = required[exports[0]] = required[exports[0]] || {};
      Object.keys(local2).forEach(function (key) {
        var match;
        /* ignore test items */
        if (key.slice(-5) === '_test') {
          return;
        }
        /* set dict items to state object */
        match = (/(.+Dict)_(.*)/).exec(key);
        if (match) {
          state[match[1]] = state[match[1]] || {};
          state[match[1]][match[2]] = local2[key];
          return;
        }
        /* set prototype items to object's prototype */
        match = (/(.+)_prototype_(.+)/).exec(key);
        if (match) {
          local2[match[1]].prototype[match[2]] = local2[key];
          return;
        }
        /* angularjs app */
        match = (/(\w+)_ngApp_(\w+)_(\w+)/).exec(key);
        if (match) {
          local2[match[1]] = local2[match[1]] || global.angular.module(match[1], []);
          local2[match[1]][match[2]](match[3], local2[key]);
          return;
        }
        /* set remaining items to exports */
        if (key[0] !== '_') {
          exports[key] = local2[key];
        }
      });
      /* wait until coverage is ready */
      if (state.modeCoverageInit <= 1) {
        return;
      }
      /* init local2._initOnce */
      state.initOnceDict = state.initOnceDict || {};
      if (local2._initOnce && !state.initOnceDict[local2._name]) {
        state.initOnceDict[local2._name] = true;
        local2._initOnce();
      }
      /* wait until utility2 is ready before running tests */
      state.testModuleDict = state.testModuleDict || { utility2: true };
      utility2.untilReadyUtility2(function () {
        /* init test */
        if ((local2._modeTest
              || (state.modeTest && state.testModuleDict[local2._name.split('.')[0]]))) {
          local._createTest(global, local2).run();
        }
      });
    },

    _moduleInit_default_test: function (onEventError) {
      /*
        this function tests initLocal's default handling behavior
      */
      utility2.testMock(onEventError, [
        [global, {
          angular: { module: function () {
            return { controller: utility2.nop };
          } },
          required: { _moduleInit_default_test: null },
          state: {
            /* test browser mode handling behavior */
            modeBrowser: true,
            /* test coverage handling behavior */
            modeCoverageInit: 2,
            /* test nodejs mode handling behavior */
            modeNodejs: true,
            /* test test mode disabled handling behavior */
            modeTest: false
          }
        }],
        [utility2, { fsWatch: utility2.nop }]
      ], function (onEventError) {
        var exports, local2;
        local2 = {
          /* test dict handling behavior */
          _aaDict_bb: true,
          /* test class handling behavior */
          _Aa: utility2.nop,
          /* test class prototype handling behavior */
          _Aa_prototype_bb: utility2.nop,
          /* test angularjs app handling behavior */
          _aa_ngApp_controller_bb: [],
          _name: '_moduleInit_default_test'
        };
        /* test default handling behavior */
        utility2.initLocal(local2);
        /* assert local2._Aa.prototype.bb exists */
        utility2.assert(local2._Aa.prototype.bb, local2._Aa.prototype);
        /* assert exports exists */
        exports = required._moduleInit_default_test;
        utility2.assert(exports, exports);
        /* assert local2._aa exists */
        utility2.assert(local2._aa, local._aa);
        onEventError();
      });
    },

    jsonCopy: function (object) {
      /*
        this function deep copies the json object using JSON.parse(JSON.stringify(object))
      */
      return JSON.parse(JSON.stringify(object));
    },

    jsonLog: function (message, data) {
      /*
        this function uses JSON.stringify to give a consistent print format
        across various javascript platforms
      */
      if (state.modeSilent) {
        return;
      }
      message = message || '';
      /* JSON.stringify data */
      if (data) {
        message += ' ' + utility2.jsonStringifyCircular(data);
      }
      /* security - scrub sensitive key / value pairs in json data from log */
      message = message.replace(
        (/"[^"]*(?:auth|key|login|passw|secret|token)[\S\s]*?([,}])/gi),
        function (_, match1) {
          utility2.nop(_);
          return match1 === ',' ? '' : match1;
        }
      );
      console.log(message);
    },

    _jsonLog_default_test: function (onEventError) {
      /*
        this function tests jsonLog's default handling behavior
      */
      var message;
      utility2.testMock(onEventError, [
        [global, { state: { modeSilent: null } }],
        [console, { log: function (_) {
          message = _;
        } }]
      ], function (onEventError) {
        /* test null arguments handling behavior */
        utility2.jsonLog();
        /* assert no message */
        utility2.assert(!message, message);
        /* test silent handling behavior */
        state.modeSilent = true;
        utility2.jsonLog('_jsonLog_default_test');
        /* assert no message */
        utility2.assert(!message, message);
        /* test default handling behavior */
        state.modeSilent = null;
        utility2.jsonLog('_jsonLog_default_test', {});
        /* assert message has json data */
        utility2.assert(message === '_jsonLog_default_test {}', message);
        /* test null json data handling behavior */
        utility2.jsonLog('_jsonLog_default_test');
        /* assert message has no json data */
        utility2.assert(message === '_jsonLog_default_test', message);
        /* test security handling behavior */
        utility2.jsonLog('_jsonLog_default_test', { secret1: 'aa', secret2: 'bb' });
        /* assert sensitive data has been scrubbed from message */
        utility2.assert(message === '_jsonLog_default_test {}', message);
        onEventError();
      });
    },

    jsonParseHandler: function (onEventError) {
      /*
        this function returns a callback that will JSON.parse the data with error handling
      */
      return function (error, data) {
        if (error) {
          onEventError(error);
          return;
        }
        try {
          /* accept undefined data */
          if (data !== undefined) {
            data = JSON.parse(data);
          }
        } catch (error2) {
          onEventError(error2);
          return;
        }
        onEventError(null, data);
      };
    },

    _jsonParseHandler_default_test: function (onEventError) {
      /*
        this function tests jsonParseHandler's default handling behavior
      */
      /* test default handling behavior */
      utility2.jsonParseHandler(function (error, data) {
        /* assert no error occurred */
        utility2.assert(!error, error);
        utility2.assert(data === '_jsonParseHandler_default_test', data);
      })(null, '"_jsonParseHandler_default_test"');
      /* test error handling behavior */
      utility2.jsonParseHandler(function (error) {
        /* assert error occurred */
        utility2.assert(error instanceof Error, error);
      })(null, '_jsonParseHandler_default_test');
      /* test undefined handling behavior */
      utility2.jsonParseHandler(function (error, data) {
        /* assert no error occurred */
        utility2.assert(!error, error);
        utility2.assert(data === undefined, data);
      })();
      onEventError();
    },

    jsonStringifyCircular: function (value, replacer, space) {
      /*
        this function JSON.stringify's the value, ignoring circular references.
        documentation for the arguments provided @
        https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Using_native_JSON
      */
      return JSON.stringify(local._jsonStringifyCircularRecurse(value, []), replacer, space);
    },

    _jsonStringifyCircular_default_test: function (onEventError) {
      /*
        this function tests jsonStringifyCircular's default handling behavior
      */
      var circular, data;
      /* test undefined handling behavior */
      data = utility2.jsonStringifyCircular(undefined);
      utility2.assert(data === undefined, data);
      /* test circular handling behavior */
      circular = {};
      circular.circular = circular;
      circular = {'aa': [1, circular, 2], 'bb': utility2.nop };
      data = utility2.jsonStringifyCircular(circular);
      utility2.assert(data === '{"aa":[1,{},2]}', data);
      onEventError();
    },

    _jsonStringifyCircularRecurse: function (value, circularList) {
      /*
        this function recurses through the value looking for circular objects
      */
      var result;
      /* return the value if its falsey */
      if (!value) {
        return value;
      }
      /* return undefined if the value is a dom element or circular */
      if ((global.HTMLElement && value instanceof global.HTMLElement)
          || circularList.indexOf(value) >= 0) {
        return;
      }
      /* return the value if JSON.stringify succeeds */
      utility2.tryCatch(function () {
        result = JSON.stringify(value);
      }, utility2.nop);
      if (result) {
        return value;
      }
      /* fallback code if JSON.stringify fails */
      /* add the value to circularList */
      circularList.push(value);
      /* the value is a function */
      if (typeof value === 'function') {
        return;
      }
      /* value is an array */
      if (Array.isArray(value)) {
        return value.map(function (element) {
          return local._jsonStringifyCircularRecurse(element, circularList);
        });
      }
      /* value is an object */
      result = {};
      Object.keys(value).forEach(function (key) {
        result[key] = local._jsonStringifyCircularRecurse(value[key], circularList);
      });
      return result;
    },

    jsonStringifyOrdered: function (value, replacer, space) {
      /*
        this function JSON.stringify's the value with dictionaries in sorted order,
        allowing reliable / reproducible string comparisons and tests
      */
      return JSON.stringify(value && (typeof value === 'object' || Array.isArray(value))
        ? JSON.parse(
          local._jsonStringifyOrderedRecurse(local._jsonStringifyCircularRecurse(value, []))
        )
        : value, replacer, space);
    },

    _jsonStringifyOrdered_default_test: function (onEventError) {
      /*
        this function tests jsonStringifyOrdered's default handling behavior
      */
      var data;
      /* test undefined handling behavior */
      data = utility2.jsonStringifyOrdered(undefined);
      utility2.assert(data === undefined, data);
      /* test function handling behavior */
      data = utility2.jsonStringifyOrdered(utility2.nop);
      utility2.assert(data === undefined, data);
      /* test default handling behavior */
      data = utility2.jsonStringifyOrdered({
        ee: {},
        dd: [undefined],
        cc: utility2.nop,
        bb: 2,
        aa: 1
      });
      utility2.assert(data === '{"aa":1,"bb":2,"dd":[null],"ee":{}}', data);
      onEventError();
    },

    _jsonStringifyOrderedRecurse: function (value) {
      /*
        this function recurses the value looking for dictionaries to order
      */
      value = Array.isArray(value)
        ? '[' + value.map(local._jsonStringifyOrderedRecurse).join(',') + ']'
        : typeof value !== 'object' || !value
        ? JSON.stringify(value)
        /* sort list of keys */
        : '{' + Object.keys(value).filter(function (key) {
          return JSON.stringify(value[key]) !== undefined;
        }).sort().map(function (key) {
          return JSON.stringify(key) + ':' + local._jsonStringifyOrderedRecurse(value[key]);
        }).join(',') + '}';
      return value === undefined ? 'null' : value;
    },

    mimeLookup: function (file) {
      /*
        this function returns the file's mime-type
      */
      file = required.path.extname(file).slice(1);
      switch (file) {
      case 'css':
        return 'text/css';
      case 'html':
        return 'text/html';
      case 'js':
        return 'application/javascript';
      case 'json':
        return 'application/json';
      case 'txt':
        return 'text/plain';
      default:
        return required.mime.lookupDict[file];
      }
    },

    _mimeLookup_default_test: function (onEventError) {
      /*
        this function tests mimeLookup's default handling behavior
      */
      var data;
      data = utility2.mimeLookup('foo.css');
      utility2.assert(data === 'text/css', data);
      data = utility2.mimeLookup('foo.html');
      utility2.assert(data === 'text/html', data);
      data = utility2.mimeLookup('foo.js');
      utility2.assert(data === 'application/javascript', data);
      data = utility2.mimeLookup('foo.json');
      utility2.assert(data === 'application/json', data);
      data = utility2.mimeLookup('foo.txt');
      utility2.assert(data === 'text/plain', data);
      data = utility2.mimeLookup('foo');
      utility2.assert(data === undefined, data);
      onEventError();
    },

    modeIncrement: function (error, mode) {
      /*
        this function increments the mode if no error occurs or returns -1
        it is used to improve conditional branch coverage in asynchronous tests
      */
      return error instanceof Error ? -1 : mode + 1;
    },

    _modeIncrement_default_test: function (onEventError) {
      /*
        this function tests modeIncrement's default handling behavior
      */
      var mode;
      mode = 0;
      /* test null error handling behavior */
      mode = utility2.modeIncrement(null, mode);
      utility2.assert(mode === 1, mode);
      /* test error handling behavior */
      mode = utility2.modeIncrement(utility2.error, mode);
      utility2.assert(mode === -1, mode);
      onEventError();
    },

    nop: function () {
      /*
        this function performs no operation (nop)
      */
      return;
    },

    _nop_default_test: function (onEventError) {
      /*
        this function tests nop's default handling behavior
      */
      utility2.nop();
      onEventError();
    },

    onEventErrorDefault: function (error, data) {
      /*
        this function provides a default, error / data handling callback.
        if an error is given, it will print the error's message and stack,
        else it will print the data
      */
      var ii;
      if (error) {
        /* ignore test-generated errors */
        for (ii = 0; ii < (state.onEventErrorDefaultIgnoreList || []).length; ii += 1) {
          if (state.onEventErrorDefaultIgnoreList[ii] === error.message) {
            state.onEventErrorDefaultIgnoreList.splice(ii, 1);
            return;
          }
        }
        /* debug error */
        state.debugError = error;
        /* print error */
        state.debugMessage
          = '\nonEventErrorDefault - error\n' + utility2.errorStack(error) + '\n';
        console.error(state.debugMessage);
      /* print data if it's defined and not an empty string */
      } else if (data !== undefined && data !== '') {
        /* debug data */
        state.debugData = data;
        state.debugMessage = '\nonEventErrorDefault - data\n'
          + utility2.jsonStringifyCircular(data, null, 2) + '\n';
        utility2.jsonLog(state.debugMessage);
      }
    },

    _onEventErrorDefault_default_test: function (onEventError) {
      /*
        this function tests onEventErrorDefault's default handling behavior
      */
      utility2.testMock(onEventError, [
        [global, { state: {} }]
      ], function (onEventError) {
        utility2.onEventErrorDefault(null, '_onEventErrorDefault_default_test');
        onEventError();
      });
    },

    _onEventErrorDefault_error_test: function (onEventError) {
      /*
        this function tests onEventErrorDefault's error handling behavior
      */
      utility2.testMock(onEventError, [
        [console, { error: utility2.nop }],
        [global, { state: {} }]
      ], function (onEventError) {
        var error;
        error = new Error('_onEventErrorDefault_error_test');
        /* test error.stack handling behavior */
        utility2.onEventErrorDefault(error);
        /* test error.message handling behavior */
        error.stack = '';
        utility2.onEventErrorDefault(error);
        /* test null error.message and null error.stack handling behavior */
        error.message = '';
        utility2.onEventErrorDefault(error);
        onEventError();
      });
    },

    _onEventErrorDefault_ignore_test: function (onEventError) {
      /*
        this function tests onEventErrorDefault's ignore handling behavior
      */
      var error;
      error = new Error(utility2.uuid4());
      /* add extraneous error message for code coverage */
      state.onEventErrorDefaultIgnoreList.push(utility2.uuid4());
      state.onEventErrorDefaultIgnoreList.push(error.message);
      utility2.onEventErrorDefault(error);
      /* remove extraneous error message */
      state.onEventErrorDefaultIgnoreList.pop();
      onEventError();
    },

    onEventTimeout: function (onEventError, timeout, message) {
      /*
        this function sets a timer to throw and handle a timeout error
      */
      var error;
      error = new Error('onEventTimeout - timeout error - ' + timeout + ' ms - ' + message);
      error.code = 'ETIMEDOUT';
      return setTimeout(function () {
        onEventError(error);
      }, timeout);
    },

    _onEventTimeout_timeout_test: function (onEventError) {
      /*
        this function tests onEventTimeout's timeout handling behavior
      */
      var time;
      time = Date.now();
      utility2.onEventTimeout(function (error) {
        utility2.tryCatch(function () {
          /* assert error occurred */
          utility2.assert(error instanceof Error);
          /* assert error is timeout error */
          utility2.assert(error.code === 'ETIMEDOUT');
          time = Date.now() - time;
          /* assert time passed is greater than timeout */
          /* bug - ie and opera may timeout slightly earlier, so increase the timeout */
          utility2.assert(1.5 * time >= 1000, time);
          onEventError();
        }, onEventError);
      }, 1000, '_onEventTimeout_timeoutError_test');
    },

    scriptLint: function (file, script) {
      /*
        this function lints css / html / js / json scripts
      */
      var result;
      switch (required.path.extname(file)) {
      /* lint css file */
      case '.css':
        result = required.csslint
          && required.csslint.getFormatter('text').formatResults(required.csslint.verify(
            script,
            { ignore: 'ids' }
          ), file, { quiet: true }).trim();
        if (result) {
          console.error('\n_scriptLintCss\n' + result + '\n');
        }
        break;
      /* lint js file */
      case '.js':
      case '.json':
        if (!global.__coverage__ && required.jslint && !required.jslint(script)) {
          console.error('\n_scriptLintJs\n' + required.colors.bold(file));
          required.jslint.errors.forEach(function (error, ii) {
            result = '#' + String(ii + 1) + ' ';
            while (result.length < 4) {
              result = ' ' + result;
            }
            if (error && error.evidence) {
              console.error(result + required.colors.yellow(error.reason)
                + '\n    ' + (error.evidence).trim() + required.colors.grey(' \/\/ Line '
                  + error.line + ', Pos ' + error.character));
            }
          });
          console.error();
        }
        break;
      }
      return script;
    },

    _scriptLint_default_test: function (onEventError) {
      /*
        this function tests scriptLint's error handling behavior
      */
      utility2.testMock(onEventError, [
        [console, { error: utility2.nop }],
        [global, { __coverage__: null }]
      ], function (onEventError) {
        /* test css default handling behavior */
        utility2.scriptLint('_scriptLint_default_test.css', '_scriptLint_default_test {}');
        /* test css error handling behavior */
        utility2.scriptLint('_scriptLint_default_test.css', '_scriptLint_default_test');
        /* test js default handling behavior */
        utility2.scriptLint('_scriptLint_default_test.js', '_scriptLint_default_test');
        /* test js error handling behavior */
        utility2.scriptLint('_scriptLint_default_test.js', 'var aa = "bb";');
        /* test js error.evidence missing handling behavior */
        utility2.testMock(onEventError, [
          [required, { jslint: function () {
            required.jslint.errors = [null];
          } }]
        ], function () {
          utility2.scriptLint('_scriptLint_default_test.js', 'var aa = "bb";');
        });
        onEventError();
      });
    },

    scriptMinify: function (file, script) {
      /*
        this function minifies css / js scripts
      */
      var ast, result;
      switch (required.path.extname(file)) {
      /* minify css file */
      case '.css':
        script = required.cssmin ? required.cssmin(script) : script;
        break;
      /* minify js file */
      case '.js':
        if (required.uglifyjs) {
          ast = required.uglifyjs.parse(script, { filename: file });
          /* figure out scope */
          ast.figure_out_scope();
          /* compress */
          ast.transform(new required.uglifyjs.Compressor());
          /* mangle */
          ast.figure_out_scope();
          ast.compute_char_frequency();
          ast.mangle_names();
          /* create output */
          result = new required.uglifyjs.OutputStream({ ascii_only: true });
          ast.print(result);
          script = result.toString();
        }
        break;
      }
      return script;
    },

    _scriptMinify_default_test: function (onEventError) {
      /*
        this function tests scriptMinify's defult handling behavior
      */
      utility2.scriptMinify('foo.css', '_scriptMinify_default_test {}');
      utility2.scriptMinify('foo.js', 'console.log("_scriptMinify_default_test");');
      onEventError();
    },

    setDefault: function (options, defaults) {
      /*
        this function recursively walks through the defaults object,
        and uses it to set default values for unset leaf nodes in the options object
      */
      Object.keys(defaults).forEach(function (key) {
        var defaults2, options2;
        defaults2 = defaults[key];
        options2 = options[key];
        /* set default value */
        if (options2 === undefined) {
          options[key] = defaults2;
          return;
        }
        /* recurse defaults2 if options2 and defaults2 are both objects */
        if (defaults2 && typeof defaults2 === 'object'
            && options2 && typeof options2 === 'object'
            && !Array.isArray(options2)) {
          local.setDefault(options2, defaults2);
        }
      });
      return options;
    },

    _setDefault_default_test: function (onEventError) {
      /*
        this function tests setDefault's default handling behavior
      */
      var options;
      options = utility2.setDefault(
        { aa: 1, bb: {}, cc: [] },
        { aa: 2, bb: { cc: 2 }, cc: [1, 2] }
      );
      utility2.assert(
        utility2.jsonStringifyOrdered(options) === '{"aa":1,"bb":{"cc":2},"cc":[]}',
        options
      );
      onEventError();
    },

    setOverride: function (state, override, backup, depth) {
      /*
        this function recursively overrides the state object with the override object,
        and optionally saves the original state object to the backup object,
        and optionally accepts the depth recursion limit
      */
      local._setOverrideRecurse(state, override, backup || {}, depth || Infinity);
      return state;
    },

    _setOverrideRecurse: function (state, override, backup, depth) {
      /*
        this function
        1. save the state item to the backup object
        2. set the override item to the state object
        3. recurse the override object
      */
      var state2, override2;
      Object.keys(override).forEach(function (key) {
        state2 = state[key];
        override2 = backup[key] = override[key];
        if (depth <= 1
            /* override2 is not a plain object */
            || !(override2 && typeof override2 === 'object' && !Array.isArray(override2))
            /* state2 is not a plain object */
            || !(state2 && typeof state2 === 'object' && !Array.isArray(state2))) {
          /* 1. save the state item to the backup object */
          backup[key] = state2;
          /* 2. set the override item to the state object */
          state[key] = override2;
          return;
        }
        /* 3. recurse the override object */
        local._setOverrideRecurse(state2, override2, override2, depth - 1);
      });
    },

    _setOverride_default_test: function (onEventError) {
      /*
        this function tests setOverride's default handling behavior
      */
      var backup, state;
      backup = {};
      /* test override */
      state = utility2.setOverride(
        { aa: 1, bb: { cc: 2 }, dd: [3, 4], ee: { ff: { gg: 5, hh: 6 } } },
        { aa: 2, bb: { dd: 3 }, dd: [4, 5], ee: { ff: { gg: 6 } } },
        backup,
        2
      );
      utility2.assert(utility2.jsonStringifyOrdered(state)
          === '{"aa":2,"bb":{"cc":2,"dd":3},"dd":[4,5],"ee":{"ff":{"gg":6}}}', state);
      /* test backup */
      utility2.assert(utility2.jsonStringifyOrdered(backup)
          === '{"aa":1,"bb":{},"dd":[3,4],"ee":{"ff":{"gg":5,"hh":6}}}', backup);
      /* test restore */
      utility2.setOverride(state, backup);
      utility2.assert(utility2.jsonStringifyOrdered(backup)
          === '{"aa":1,"bb":{"dd":3},"dd":[3,4],"ee":{"ff":{"gg":6}}}', backup);
      utility2.assert(utility2.jsonStringifyOrdered(state)
          === '{"aa":1,"bb":{"cc":2},"dd":[3,4],"ee":{"ff":{"gg":5,"hh":6}}}', state);
      onEventError();
    },

    _Test: function () {
      /*
        this is the _Test class
      */
      return;
    },

    _Test_prototype_report: function () {
      /*
        this function creates a test report
      */

      var self, state;
      self = this;
      state = self.global.state;
      utility2.testReportMerge(state.testReport);
      utility2.testReportLog(state.testReport);
      /* record total time for all testPlatforms to run */
      state.testReport.totalTime = utility2.timeElapsed(state.testReport.totalTime);
      /* copy state.testReport */
      state.testReportCopy = utility2.jsonCopy(state.testReport);
      /* reset state.testReport */
      state.testReport = utility2.testReportMerge({});
      /* browser code */
      if (state.modeBrowser) {
        /* notify saucelabs of test results */
        self.global.global_test_results = {
          coverage: global.__coverage__,
          testCallbackId: state.testCallbackId,
          testReport: state.testReportCopy,
          /* extra stuff to keep saucelabs happy - https://saucelabs.com/docs/rest#jsunit */
          failed: state.testReportCopy.testsFailed,
          passed: state.testReportCopy.testsPassed
        };
        if (utility2.urlParamsGet(self.global.location.hash, '#').testReportUpload) {
          utility2.ajax({
            data: JSON.stringify(self.global.global_test_results),
            url: '/test/testReportUpload?userAgent='
              + encodeURIComponent(self.global.navigator.userAgent)
          }, function (error) {
            utility2.onEventErrorDefault(error);
          });
        }
        /* update state.testReportDiv in browser */
        state.testReportDiv.innerHTML = utility2.testReportHtml(state.testReportCopy);
        utility2.clearCallSetInterval('testReportDivUpdate', 'clear');
      }
      /* nodejs code */
      if (state.modeNodejs) {
        /* wait for any async jobs to finish before reporting test results */
        setTimeout(function () {
          utility2.testReportNodejs(state.testReportCopy);
        }, 100);
      }
    },

    __Test_prototype_report_testsFailed_test: function (onEventError) {
      /*
        this function tests _Test_prototype_report's tests failed handling behavior
      */
      utility2.testMock(onEventError, [
        [utility2, {
          ajax: utility2.callArg1,
          clearCallSetInterval: utility2.nop,
          onEventErrorDefault: null
        }]
      ], function (onEventError) {
        var self;
        self = local._createTest({
          location: { hash: '' },
          navigator: {},
          state: {
            /* test browser mode handling behavior */
            modeBrowser: true,
            /* test multiple test platforms handling behavior */
            testReport: utility2.testReportMerge({ testPlatformList: [
              /* test tests failed handling behavior */
              { name: 'bb', testCaseList: [{ errorMessage: 'error' }] },
              { name: 'aa', testCaseList: [{ errorMessage: 'error' }] }
            ] }),
            /* test state.testReportDiv handling behavior */
            testReportDiv: {}
          }
        });
        /* test report upload disabled handling behavior */
        self.report();
        /* test report upload handling behavior */
        self.global.location.hash = '#testReportUpload=1';
        utility2.onEventErrorDefault = onEventError;
        self.report();
      });
    },

    _Test_prototype_run: function () {
      /*
        this function runs all tests for a given module
      */
      var self, state, testPlatform;
      self = this;
      state = self.global.state;
      /* create user agent test group */
      testPlatform = utility2.userAgent();
      state.testReport.testPlatformList.forEach(function (value) {
        if (value.name === testPlatform) {
          testPlatform = value;
        }
      });
      if (typeof testPlatform !== 'object') {
        testPlatform = {
          name: testPlatform,
          testCaseList: [],
          totalTime: Date.now()
        };
        state.testReport.testPlatformList.push(testPlatform);
        state.testReport.onEventReady.remaining += 1;
      }
      /* init testPlatform.onEventReady */
      testPlatform.onEventReady = testPlatform.onEventReady || utility2.untilReady(function () {
        /* record time for testPlatform to run */
        testPlatform.totalTime = utility2.timeElapsed(testPlatform.totalTime);
        state.testReport.onEventReady();
      });
      /* handle null case where there are no test cases to run */
      testPlatform.onEventReady.remaining += 1;
      self.global.setTimeout(testPlatform.onEventReady);
      /* loop through all tests in local2 */
      Object.keys(self.local2).forEach(function (testCase) {
        if (testCase.slice(-5) === '_test') {
          testPlatform.onEventReady.remaining += 1;
          testCase = {
            errorMessage: '',
            module: self.local2._name,
            name: testCase,
            time: Date.now()
          };
          testPlatform.testCaseList.push(testCase);
          self.runTestCase(testCase, testPlatform);
        }
      });
    },

    __Test_prototype_run_testsFailed_test: function (onEventError) {
      /*
        this function tests _Test_prototype_run's tests failed handling behavior
      */
      var self, data;
      self = local._createTest({
        console: { error: utility2.nop },
        setTimeout: utility2.callArg0,
        state: { testModuleDict: {}, testReport: utility2.testReportMerge({
          onEventReady: utility2.nop,
          testPlatformList: [{ testCaseList: [] }]
        }) }
      }, {
        _name: 'utility2.__Test_prototype_run_testsFailed_test',
        _test: function (onEventError) {
          state.onEventErrorDefaultIgnoreList.push('utility2 error');
          state.onEventErrorDefaultIgnoreList.push('runTestCase - ' + utility2.userAgent()
            + ' - utility2.__Test_prototype_run_testsFailed_test._test\'s'
            + ' callback called multiple times');
          /* test tests failed handling behavior */
          onEventError(utility2.error);
          /* test multiple callback error handling behavior */
          onEventError();
        }
      });
      self.run();
      data = self.global.state.testReport.testPlatformList[1].testCaseList[0].errorMessage;
      utility2.assert(data, data);
      onEventError();
    },

    __Test_prototype_run_testsSkipped_test: function (onEventError) {
      /*
        this function tests _Test_prototype_run's tests skipped handling behavior
      */
      var self, data;
      self = local._createTest({
        console: { error: utility2.nop },
        setTimeout: utility2.callArg0,
        state: {
          testModuleDict: { 'utility2.__Test_prototype_run_testsSkipped_test': false },
          testReport: utility2.testReportMerge({
            onEventReady: utility2.nop
          })
        }
      }, {
        _name: 'utility2.__Test_prototype_run_testsSkipped_test',
        _test: utility2.callArg0
      });
      self.run();
      data = self.global.state.testReport.testPlatformList[0].testCaseList[0].status;
      utility2.assert(data === 'skipped', data);
      onEventError();
    },

    _Test_prototype_runTestCase: function (testCase, testPlatform) {
      /*
        this function creates a testCase object from the given testName
        and runs it asynchronously
      */
      var errorMessage, name, onEventError2, remaining, self, state, timeout;
      self = this;
      state = self.global.state;
      /* handle testCase result */
      onEventError2 = function (error) {
        /* clear timeout for testCase */
        clearTimeout(timeout);
        name = testPlatform.name + ' - ' + testCase.module + '.' + testCase.name;
        /* assert testCase callback was not called multiple times */
        remaining -= 1;
        if (remaining < 0) {
          error = error || new Error(
            'runTestCase - ' + name + "'s callback called multiple times"
          );
        }
        /* testCase failed */
        if (error) {
          /* save error message */
          errorMessage = 'runTestCase - failed - ' + name;
          self.global.console.error(required.colors.inverse('\n' + errorMessage));
          utility2.onEventErrorDefault(error);
          errorMessage += state.debugMessage;
          testCase.errorMessage = errorMessage;
          state.testReport.errorMessageList.push(errorMessage);
          if (remaining < 0) {
            return;
          }
        }
        /* record time for testCase to run */
        testCase.time = utility2.timeElapsed(testCase.time);
        /* finish testCase */
        testPlatform.onEventReady();
      };
      remaining = 1;
      /* set timeout for testCase */
      timeout = utility2.onEventTimeout(
        onEventError2,
        /* slightly increase timeout to allow for individual test timeouts */
        1.0625 * state.timeoutDefault,
        'runTestCase'
      );
      utility2.tryCatch(function () {
        /* skip testCase */
        if (state.testModuleDict[testCase.module] === false) {
          testCase.status = 'skipped';
          testCase.time = 0;
          onEventError2();
          return;
        }
        /* run testCase */
        self.local2[testCase.name](onEventError2);
        /* catch synchronously thrown errors */
      }, onEventError2);
    },

    testMock: function (onEventError, mockList, test) {
      /*
        this function mocks the state given in the mockList while running the test callback
      */
      var onEventError2;
      /* prepend mandatory mocks for async / unsafe functions */
      mockList = [
        /* suppress console.log */
        [console, { log: utility2.nop }],
        /* enforce synchonicity by mocking timers as utility2.callArg0 */
        [global, { setInterval: utility2.callArg0, setTimeout: utility2.callArg0 }],
        [global.process || {}, { exit: utility2.throwError }],
        [utility2, { shell: utility2.throwError }]
      ].concat(mockList);
      onEventError2 = function (error) {
        /* restore state */
        mockList.reverse().forEach(function (mock) {
          utility2.setOverride(mock[0], mock[2], null, 1);
        });
        if (error) {
          onEventError(error);
        }
      };
      /* run onEventError callback in mocked state in a try catch block */
      utility2.tryCatch(function () {
        /* mock state */
        mockList.forEach(function (mock) {
          mock[2] = {};
          utility2.setOverride(mock[0], mock[1], mock[2], 1);
        });
        /* run test */
        test(onEventError);
        onEventError2();
      }, onEventError2);
    },

    _testMock_error_test: function (onEventError) {
      /*
        this function tests testMock's error handling behavior
      */
      utility2.testMock(onEventError, [
        [global, { state: { aa: 1 } }]
      ], function (onEventError) {
        utility2.testMock(function (error) {
          /* assert error occurred */
          utility2.assert(error instanceof Error, error);
          utility2.assert(state.aa === 1, state);
          onEventError();
        }, [
          [state, { aa: 2 }]
        ], function () {
          throw utility2.error;
        });
      });
    },

    testReportHtml: function (testReport) {
      /*
        this function creates an html test report
      */
      var errorMessageList, processEnv, testCaseNumber;
      processEnv = (global.process && process.env) || {};
      testCaseNumber = 0;
      testReport = utility2.jsonCopy(utility2.testReportMerge(testReport));
      return utility2.textFormat(
        state.fsWatchDict['/public/utility2/testReport.html.template'].contentBrowser,
        utility2.setOverride(testReport, {
          CI_BUILD_NUMBER: processEnv.CI_BUILD_NUMBER,
          /* security - sanitize '<' in text */
          CI_COMMIT_INFO: String(processEnv.CI_COMMIT_INFO).replace((/</g), '&lt;'),
          GITHUB_REPO_URL: processEnv.GITHUB_REPO_URL,
          GITHUB_REPO_URL_HREF: processEnv.GITHUB_REPO_URL || '#',
          /* map testPlatformList */
          testPlatformList: testReport.testPlatformList.map(function (testPlatform, ii) {
            errorMessageList = [];
            return utility2.setOverride(testPlatform, {
              errorMessageList: errorMessageList,
              /* security - sanitize '<' in text */
              name: String(testPlatform.name).replace((/</g), '&lt;'),
              /* map testCaseList */
              testCaseList: testPlatform.testCaseList.map(function (testCase) {
                testCaseNumber += 1;
                if (testCase.errorMessage) {
                  /* word wrap error message 128 characters in pre tag */
                  errorMessageList.push({ errorMessage: utility2.textWordwrap(testCaseNumber
                    + '. ' + testCase.module + '.' + testCase.name + '\n'
                    + testCase.errorMessage, 96)
                      /* security - sanitize '<' in text */
                      .replace((/</g), '&lt;') });
                }
                return utility2.setOverride(testCase, {
                  name: testCase.module + '.' + testCase.name,
                  testCaseNumber: testCaseNumber,
                  testReportTestStatusClass: 'testReportTest'
                    + testCase.status[0].toUpperCase() + testCase.status.slice(1),
                  time: utility2.timeElapsed(testCase.time)
                });
              }),
              testReportPlatformPreClass: 'testReportPlatformPre'
                + (errorMessageList.length ? '' : 'Hidden'),
              testPlatformNumber: ii + 1,
              totalTime: utility2.timeElapsed(testPlatform.totalTime)
            });
          }),
          testsFailedClass: testReport.testsFailed
            ? 'testReportTestFailed'
            : 'testReportTestPassed',
          testsSkippedClass: testReport.testsSkipped
            ? 'testReportTestSkipped'
            : 'testReportTestPassed',
          totalTime: utility2.timeElapsed(testReport.totalTime)
        })
      );
    },

    _testReportHtml_default_test: function (onEventError) {
      /*
        this function tests testReportHtml's default handling behavior
      */
      var data;
      data = utility2.testReportHtml({
        testPlatformList: [{ testCaseList: [
          /* test test failed handling behavior */
          { errorMessage: 'error' },
          /* test test passed handling behavior */
          { time: 0 },
          /* test test pending handling behavior */
          { time: Date.now() },
          /* test test skipped handling behavior */
          { status: 'skipped' }
        ] }]
      });
      /* assert test failed */
      utility2.assert(data.indexOf('<td class="testReportTestFailed">1</td>') >= 0, data);
      /* assert test passed */
      utility2.assert(data.indexOf('<td class="testReportTestPassed">1</td>') >= 0, data);
      /* assert test skipped */
      utility2.assert(data.indexOf('<td class="testReportTestSkipped">1</td>') >= 0, data);
      onEventError();
    },

    testReportLog: function (testReport) {
      /*
        this function prints a human-readable summary of the testReport
      */
      var result;
      result = '\n\n\ntest report - ' + utility2.userAgent() + '\n';
      /* merge testReport */
      testReport.testPlatformList.forEach(function (testPlatform) {
        result += (testPlatform.testsFailed ? required.colors.inverse : utility2.echo)(
          ('        ' + testPlatform.totalTime).slice(-8) + ' ms | '
            + (' ' + testPlatform.testsFailed).slice(-2) + ' failed | '
            + (' ' + testPlatform.testsSkipped).slice(-2) + ' skipped | '
            + ('  ' + testPlatform.testsPassed).slice(-3) + ' passed in '
            + testPlatform.name + '\n'
        );
      });
      result += '\n' + testReport.errorMessageList.join('\n') + '\n';
      utility2.jsonLog(result);
    },

    testReportMerge: function (testReport1, testReport2) {
      /*
        this function merges testReport2 into testReport1
      */
      var testPlatform1;
      utility2.assert(
        testReport1 && typeof testReport1 === 'object',
        'invalid testReport1 ' + typeof testReport1
      );
      testReport1 = utility2.setDefault(testReport1, {
        errorMessageList: [],
        testPlatformList: [],
        totalTime: 0
      });
      testReport2 = testReport2 || {};
      (testReport2.errorMessageList || []).forEach(function (errorMessage) {
        testReport1.errorMessageList.push(String(errorMessage));
      });
      (testReport2.testPlatformList || []).forEach(function (testPlatform2) {
        testPlatform1 = null;
        /* security - fix potentially malformed testPlatform2 */
        testPlatform2 = testPlatform2 || {};
        testPlatform2.name = String(testPlatform2.name);
        testPlatform2.totalTime = Number(testPlatform2.totalTime) || 0;
        testReport1.testPlatformList.forEach(function (_) {
          /* use existing testPlatform1 */
          if (_.name === testPlatform2.name) {
            testPlatform1 = _;
          }
        });
        /* crate new testPlatform1 */
        if (!testPlatform1) {
          testPlatform1 = {
            name: testPlatform2.name,
            testCaseList: [],
            totalTime: 0
          };
          testReport1.testPlatformList.push(testPlatform1);
        }
        /* merge testPlatform2 into testPlatform1 */
        testPlatform1.totalTime += testPlatform2.totalTime;
        /* merge testPlatform2.testCaseList into testPlatform1.testCaseList */
        if (Array.isArray(testPlatform2.testCaseList)) {
          testPlatform2.testCaseList.forEach(function (testCase) {
            /* security - fix potentially malformed testCase */
            testCase.errorMessage = String(testCase.errorMessage || '');
            testCase.module = String(testCase.module);
            testCase.name = String(testCase.name);
            testCase.time = Number(testCase.time) || 0;
            testPlatform1.testCaseList.push(testCase);
          });
        }
      });
      /* update date */
      testReport1.date = testReport1.date || new Date().toISOString();
      /* update totalTime */
      if (testReport1.totalTime < 0xffffffff) {
        testReport1.totalTime += Number(testReport2.totalTime) || 0;
      }
      testReport1.platformsFailed = 0;
      testReport1.platformsPassed = 0;
      testReport1.testsFailed = 0;
      testReport1.testsPassed = 0;
      testReport1.testsPending = 0;
      testReport1.testsSkipped = 0;
      testReport1.testPlatformList.forEach(function (testPlatform1) {
        testPlatform1.status = 'passed';
        testPlatform1.testsFailed = 0;
        testPlatform1.testsPassed = 0;
        testPlatform1.testsSkipped = 0;
        testPlatform1.testCaseList.forEach(function (testCase) {
          /* update tests skipped */
          if (testCase.status === 'skipped') {
            testReport1.testsSkipped += 1;
            testPlatform1.testsSkipped += 1;
          /* update tests failed */
          } else if (testCase.errorMessage) {
            testCase.status = 'failed';
            testReport1.testsFailed += 1;
            testPlatform1.testsFailed += 1;
            testPlatform1.status = 'failed';
          /* update tests pending */
          } else if (testCase.time > 0xffffffff) {
            testCase.status = 'pending';
            testReport1.testsPending += 1;
            if (testPlatform1.status !== 'failed') {
              testPlatform1.status = 'pending';
            }
          /* update tests passed */
          } else {
            testCase.status = 'passed';
            testReport1.testsPassed += 1;
            testPlatform1.testsPassed += 1;
          }
        });
        switch (testPlatform1.status) {
        case 'failed':
          /* update platforms failed */
          testReport1.platformsFailed += 1;
          break;
        case 'passed':
          /* update platforms passed */
          testReport1.platformsPassed += 1;
          break;
        }
        /* sort testCaseList by status.module.name */
        testPlatform1.testCaseList.sort(function (arg1, arg2) {
          arg1 = String(arg1.status.replace('passed', 'z') + arg1.module + arg1.name)
            .toLowerCase();
          arg2 = String(arg2.status.replace('passed', 'z') + arg2.module + arg2.name)
            .toLowerCase();
          return arg1 <= arg2 ? -1 : 1;
        });
      });
      /* sort testPlatformList by status.name */
      testReport1.testPlatformList.sort(function (arg1, arg2) {
        arg1 = String(arg1.status.replace('passed', 'z') + arg1.name).toLowerCase();
        arg2 = String(arg2.status.replace('passed', 'z') + arg2.name).toLowerCase();
        return arg1 <= arg2 ? -1 : 1;
      });
      return testReport1;
    },

    _testReportMerge_malformedData_test: function (onEventError) {
      /*
        this funciton tests testReportMerge's malformed data handling behavior
      */
      utility2.testReportMerge({
        errorMessageList: [],
        testPlatformList: [{ name: 'aa', testCaseList: [] }]
      }, {
        errorMessageList: [null],
        testPlatformList: [null, { name: 'aa' }]
      });
      onEventError();
    },

    timeElapsed: function (time) {
      /*
        this function calculates the time elapsed from present if not already set
      */
      time = time < 0xffffffff ? time : Date.now() - time;
      return time || 0;
    },

    /* ascii character reference */
    textExampleAscii: '\x00\x01\x02\x03\x04\x05\x06\x07\b\t\n\x0b\f\r\x0e\x0f'
      + '\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1a\x1b\x1c\x1d\x1e\x1f'
      + ' !"#$%&\'()*+,-./0123456789:;<=>?'
      + '@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_'
      + '`abcdefghijklmnopqrstuvwxyz{|}~\x7f',

    /* require('crypto').createHash('sha1').update(new Buffer(0)).digest('hex') */
    textExampleSha1: 'da39a3ee5e6b4b0d3255bfef95601890afd80709',

    /* utility2.uuid4() */
    textExampleUuid4: 'aaaaaaaa-aaaa-4aaa-baaa-aaaaaaaaaaaa',

    /* new Buffer(utility2.textExampleAscii).toString('base64') */
    textExampleBase64: 'AAECAwQFBgcICQoLDA0ODxAREhMUFRYXGBkaGxwd'
      + 'Hh8gISIjJCUmJygpKissLS4vMDEyMzQ1Njc4OTo7'
      + 'PD0+P0BBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZ'
      + 'WltcXV5fYGFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3'
      + 'eHl6e3x9fn8=',

    textFormat: function (template, dict) {
      /*
        this function replaces the keys in given text template
        with the key / value pairs provided by the dict
      */
      var value;
      dict = dict || {};
      /* search for keys in the template */
      return local._textFormatList(template, dict).replace((/\{\{[^{}]+\}\}/g), function (key) {
        /* lookup key's value in the dict */
        value = key.slice(2, -2);
        return dict.hasOwnProperty(value) ? dict[value] : key;
      });
    },

    _textFormat_default_test: function (onEventError) {
      /*
        this function tests textFormat's default handling behavior
      */
      var data;
      data = utility2.textFormat('{{aa}}{{aa}}{{bb}}{{bb}}{{cc}}{{cc}}', {
        /* test string handling behavior */
        aa: 'aa',
        /* test non-string handling behavior */
        bb: undefined
      });
      utility2.assert(data === 'aaaaundefinedundefined{{cc}}{{cc}}', data);
      /* test list handling behavior */
      data = utility2.textFormat('[{{@list1}}[{{@list2}}{{aa}},{{/@list2}}],{{/@list1}}]', {
        list1: [
          /* test null handling behavior */
          null,
          /* test recursive list handling behavior */
          { list2: [{ aa: 'bb' }, { aa: 'cc' }] }
        ]
      });
      utility2.assert(data === '[[{{@list2}}{{aa}},{{/@list2}}],[bb,cc,],]', data);
      onEventError();
    },

    _textFormatList: function (template, dict) {
      /*
        this function replaces the keys in given text template
        with the key / value pairs provided by the dict
      */
      var rgx, match, onEventReplace;
      onEventReplace = function (_, fragment) {
        utility2.nop(_);
        return dict[match].map(function (dict) {
          return utility2.textFormat(fragment, dict);
        }).join('');
      };
      rgx = (/\{\{@[^{]+\}\}/g);
      while (true) {
        /* search for array keys in the template */
        match = rgx.exec(template);
        if (!match) {
          break;
        }
        /* lookup key's value in the dict */
        match = match[0].slice(3, -2);
        if (Array.isArray(dict[match])) {
          template = template.replace(
            new RegExp('\\{\\{@' + match + '\\}\\}([\\S\\s]*?)\\{\\{\\/@' + match + '\\}\\}'),
            onEventReplace
          );
        }
      }
      return template;
    },

    textWordwrap: function (text, width) {
      /*
        this function word wraps the text to the specified width
      */
      width -= 1;
      return text.split('\n').map(function (line) {
        for (text = [line]; line.length > width + 1; line = text[text.length - 1]) {
          line = [line.slice(0, width) + '\\', '        ' + line.slice(width)];
          text.splice(text.length - 1, 1, line[0], line[1]);
        }
        return text.join('\n');
      }).join('\n');
    },

    _textWordwrap_default_test: function (onEventError) {
      /*
        this function tests textWordwrap's default handling behavior
      */
      utility2.textWordwrap(utility2.textExampleAscii, 80).split('\n').forEach(function (line) {
        /* assert line is 80 characters or less */
        utility2.assert(line.length <= 80, line.length);
      });
      onEventError();
    },

    throwError: function () {
      /*
        this function always throws an error
      */
      throw utility2.error;
    },

    _throwError_default_test: function (onEventError) {
      /*
        this function tests throwError's default handling behavior
      */
      utility2.tryCatch(utility2.throwError, function (error) {
        /* assert error occurred */
        utility2.assert(error instanceof Error, error);
        onEventError();
      }, onEventError);
    },

    tryCatch: function (callback, onEventError) {
      /*
        this function calls the callback in a try catch block,
        and falls back to onEventError if an error is thrown
      */
      try {
        callback();
      } catch (error) {
        onEventError(error);
      }
    },

    tryCatchHandler: function (onEventError) {
      /*
        this function returns a callback that will call onEventError in a try catch block
      */
      return function (error, data) {
        if (error) {
          onEventError(error);
          return;
        }
        try {
          onEventError(null, data);
        } catch (error2) {
          onEventError(error2);
        }
      };
    },

    unref: function (obj) {
      /*
        this function unref's the object under nodejs
      */
      if (obj && obj.unref) {
        obj.unref();
      }
      return obj;
    },

    untilReady: function (onEventError) {
      /*
        this function defers the onEventError callback until the remaining counter goes to zero
      */
      var self;
      self = function (error) {
        /* save any errors encountered */
        self.error = self.error || error;
        self.remaining -= 1;
        if (self.remaining === 0) {
          onEventError(self.error);
        }
        /* assert remaining >= 0 */
        utility2.assert(self.remaining >= 0, 'invalid self.remaining ' + self.remaining);
      };
      self.remaining = 0;
      return self;
    },

    _untilReady_error_test: function (onEventError) {
      /*
        this function tests untilReady's error handling behavior
      */
      var onEventReady;
      onEventReady = utility2.untilReady(function (error) {
        /* assert error occurred */
        utility2.assert(error instanceof Error, error);
      });
      onEventReady.remaining += 1;
      /* test error handling behavior */
      onEventReady(utility2.error);
      /* test multiple callback error handling behavior */
      utility2.tryCatch(onEventReady, function (error) {
        /* assert error occurred */
        utility2.assert(error instanceof Error, error);
        onEventError();
      });
    },

    urlDecodeOrError: function (text) {
      /*
        this function returns an error if the text cannot be decoded
      */
      try {
        return decodeURIComponent(text);
      } catch (error) {
        return error;
      }
    },

    _urlDecodeOrError_error_test: function (onEventError) {
      /*
        this function tests urlDecodeOrError's error handling behavior
      */
      var data;
      data = utility2.urlDecodeOrError(utility2.textExampleAscii);
      utility2.assert(data instanceof Error, data);
      onEventError();
    },

    urlParamsGet: function (url, delimiter) {
      /*
        this function returns a dictionary containing the url hash / search params
      */
      var params;
      params = {};
      url = required.url.parse(url);
      url = delimiter === '#' ? url.hash : url.search;
      (url || '').slice(1).replace((/([^&]+)=([^&]+)/g), function (_, key, value) {
        utility2.nop(_);
        /* validate key / value */
        key = utility2.urlDecodeOrError(key);
        value = utility2.urlDecodeOrError(value);
        if (!((key instanceof Error) || (value instanceof Error))) {
          params[key] = value;
        }
      });
      return params;
    },

    _urlParamsGet_default_test: function (onEventError) {
      /*
        this function tests urlParamsGet's default handling behavior
      */
      var data;
      data = utility2.urlParamsGet('/aa?bb=cc%2B#dd=ee%2B&ff=%%', '?');
      utility2.assert(utility2.jsonStringifyOrdered(data) === '{"bb":"cc+"}', data);
      data = utility2.urlParamsGet('/aa?bb=cc%2B#dd=ee%2B&ff=%%', '#');
      utility2.assert(utility2.jsonStringifyOrdered(data) === '{"dd":"ee+"}', data);
      onEventError();
    },

    urlParamsMerge: function (url, params, delimiter) {
      /*
        this function merges the url hash / search with the given params
      */
      params = utility2.setOverride(utility2.urlParamsGet(url, delimiter), params);
      params = Object.keys(params).sort().map(function (key) {
        return encodeURIComponent(key) + '=' + encodeURIComponent(params[key]);
      }).join('&');
      url = required.url.parse(url);
      return [
        url.protocol ? url.protocol + '//' : '',
        url.host,
        url.pathname,
        delimiter === '#' ? url.search : '?' + params,
        delimiter === '#' ? '#' + params : url.hash
      ].map(function (arg) {
        return arg || '';
      }).join('');
    },

    _urlParamsMerge_default_test: function (onEventError) {
      /*
        this function tests urlParamsMerge's default handling behavior
      */
      var data;
      data = utility2.urlParamsMerge('http://localhost/aa#dd=ee%2B', { bb: 'cc+' }, '?');
      utility2.assert(data === 'http://localhost/aa?bb=cc%2B#dd=ee%2B', data);
      data = utility2.urlParamsMerge('/aa#dd=ee%2B', { bb: 'cc+' }, '?');
      utility2.assert(data === '/aa?bb=cc%2B#dd=ee%2B', data);
      data = utility2.urlParamsMerge('/aa?bb=cc%2B', { dd: 'ee+' }, '#');
      utility2.assert(data === '/aa?bb=cc%2B#dd=ee%2B', data);
      onEventError();
    },

    urlParamsRemove: function (url, keyList, delimiter) {
      /*
        this function removes the given keys from the url hash / search params
      */
      var params;
      params = utility2.urlParamsGet(url, delimiter);
      keyList.forEach(function (key) {
        delete params[key];
      });
      return utility2.urlParamsMerge(
        url.replace(delimiter === '#' ? (/#.*/) : (/\?[^#]*/), ''),
        params,
        delimiter
      );
    },

    _urlParamsRemove_default_test: function (onEventError) {
      /*
        this function tests urlParamsRemove's default handling behavior
      */
      var data;
      data = utility2.urlParamsRemove('/aa?bb=cc%2B#dd=ee%2B', ['bb'], '?');
      utility2.assert(data === '/aa?#dd=ee%2B', data);
      data = utility2.urlParamsRemove('/aa?bb=cc%2B#dd=ee%2B', ['dd'], '#');
      utility2.assert(data === '/aa?bb=cc%2B#', data);
      onEventError();
    },

    userAgent: function () {
      /*
        this function returns the current javascript platform's user agent
      */
      return state.modeNodejs
        ? 'nodejs - ' + (global.process && (process.platform + ' ' + process.version))
          + ' - ' + (global.process && process.env && process.env.MODE_CI_BUILD)
        : 'browser - ' + (global.navigator && navigator.userAgent);
    },

    _userAgent_default_test: function (onEventError) {
      /*
        this function tests userAgent's default handling behavior
      */
      utility2.testMock(onEventError, [
        [global, { state: { modeNodejs: null, modeBrowser: null } }]
      ], function (onEventError) {
        var data;
        /* test nodejs mode handling behavior */
        state.modeBrowser = false;
        state.modeNodejs = true;
        data = utility2.userAgent();
        utility2.assert((/^nodejs - /).test(data), data);
        /* test browser mode handling behavior */
        state.modeBrowser = true;
        state.modeNodejs = false;
        data = utility2.userAgent();
        utility2.assert((/^browser - /).test(data), data);
        onEventError();
      });
    },

    uuid4: function () {
      /*
        this function returns a uuid4 string of form xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx
      */
      /*jslint bitwise: true*/
      var id, ii;
      id = '';
      for (ii = 0; ii < 32; ii += 1) {
        switch (ii) {
        case 8:
        case 20:
          id += '-';
          id += (Math.random() * 16 | 0).toString(16);
          break;
        case 12:
          id += '-';
          id += '4';
          break;
        case 16:
          id += '-';
          id += (Math.random() * 4 | 8).toString(16);
          break;
        default:
          id += (Math.random() * 16 | 0).toString(16);
        }
      }
      return id;
    }

  };
  local._init();
}());



(function moduleInitNodejs() {
  /*
    this nodejs module inits utility2
  */
  'use strict';
  var local;
  local = {

    _name: 'utility2.moduleInitNodejs',

    _init: function () {
      if (state.modeNodejs) {
        /* require builtin nodejs modules */
        [
          'child_process', 'crypto',
          'fs',
          'http', 'https',
          'module',
          'os',
          'path',
          'repl',
          'stream',
          'url',
          'util',
          'vm'
        ].forEach(function (module) {
          required[module] = required[module] || utility2.require(module);
        });
        /* subclass local._StreamReadableMock from stream.Readable */
        required.util.inherits(local._StreamReadableMock, required.stream.Readable);
        utility2.initLocal(local);
        local._initOnce();
        local._initSandbox();
      }
    },

    _initSandbox: function () {
      var data2;
      data2 = required.fs.readFileSync('/home/kaizhu/tmp/a00.txt', 'utf8');
      data2 = data2.trim().replace((/<\/[^>]*>/g), '');
      debugPrint(
        data2.trim().split(/<tr[^>]*>/)
          .map(function (row) {
            row = row.trim().split(/<td[^>]*>/);
            return [
              new Date(row[1]).getTime(),
              Number((row[4] || '').replace((/[^\-+0-9]*/g), '')),
              row[2]
            ];
          })
          .filter(function (row) {
            return row[0];
          })
      );
      return;
    },

    _initOnce: function () {
      if (state.modeCoverageInit > 1) {
        return;
      }
      /* indicate coverage is ready */
      state.modeCoverageInit += 1;

      /* parse commandline arguments */
      local._initOnceArgv();
      /* init npm test mode */
      local._initOnceNpmTest();
      /* init utility2.readyUtility2Exit */
      utility2.readyUtility2Exit = utility2.readyUtility2Exit
        || utility2.untilReady(function (error) {
          if (error) {
            utility2.onEventErrorDefault(error);
          }
          process.exit(!!error);
        });
      /* init tmpdir */
      if (state.tmpdir) {
        local._initOnceTmpdir();
      }
      utility2.untilReadyUtility2(function () {
        (state.modeCliDict[state.modeCli] || utility2.nop)();
      });
      /* init interactive repl debugger */
      if (state.modeRepl && !state.repl) {
        state.repl = required.repl.start({
          eval: function (script, __, ___, onEventError) {
            utility2.nop(__, ___);
            utility2.evalOnEventError('<repl>', utility2.replParse(script), onEventError);
          },
          useGlobal: true
        });
      }
      /* init utility2.__filename */
      utility2.__filename = utility2.__filename || utility2.__dirname + '/utility2.cli.js';
      /* watch files */
      utility2.fsWatch({
        actionList: ['lint', 'eval'],
        file: utility2.__filename
      });
      utility2.fsWatch({
        actionList: ['lint', 'eval'],
        file: utility2.__dirname + '/utility2.js2'
      });
      utility2.fsWatch({
        actionList: ['lint'],
        file: process.cwd() + '/public/app.js'
      });
    },

    __initOnce_default_test: function (onEventError) {
      /*
        this function tests _initOnce's default handling behavior
      */
      utility2.testMock(onEventError, [
        [global, {
          required: { fs: { exists: utility2.callArg1 } },
          state: {}
        }],
        [utility2, { fsWatch: utility2.nop, untilReadyUtility2: utility2.nop }],
        [local, { _initOnceArgv: utility2.nop, _initOnceNpmTest: utility2.nop }]
      ], function (onEventError) {
        local._initOnce();
        onEventError();
      });
    },

    _initOnceArgv: function () {
      /*
        this function parses commandline arguments and integrates it into the state dict
      */
      var argv, key2, value;
      /* init process.argv */
      argv = utility2.jsonCopy(process.argv);
      /* process argv from process.env.npm_config_utility2_* */
      Object.keys(process.env).forEach(function (key) {
        key2 = (/^npm_config_utility2_(.+)/).exec(key);
        if (key2) {
          argv.push('--' + key2[1] + '=' + (process.env[key] || 'false'));
        }
      });
      argv.forEach(function (arg, ii) {
        arg = arg.split('=');
        /* --foo=true -> state.foo = 1 */
        value = arg.slice(1).join('=')
          || (((/^--[a-z]/).test(argv[ii + 1]) || (ii + 1) >= argv.length)
            /* --foo -> state.foo = true */
            ? 'true'
            /* --foo true -> state.foo = true */
            : argv[ii + 1]);
        arg = arg[0];
        /* --no-foo -> state.foo = false */
        if ((/^--no-[a-z]/).test(arg)) {
          arg = '-' + arg.slice(4);
          value = 'false';
        }
        arg = local._textToCamelCase(arg.slice(2));
        try {
          state[arg] = JSON.parse(value);
        } catch (error) {
          state[arg] = value;
        }
      });
    },

    __initOnceArgv_default_test: function (onEventError) {
      /*
        this function tests _initOnceArgv's default handling behavior
      */
      utility2.testMock(onEventError, [
        [global, {
          process: {
            cwd: process.cwd,
            env: {
              /* test npm argument handling behavior */
              npm_config_utility2_aa: '',
              npm_config_utility2_bb: '1'
            },
            exit: utility2.nop,
            on: utility2.callArg1
          },
          state: { modeCli: 'exportEnv' }
        }]
      ], function (onEventError) {
        process.argv = ['--cc'];
        local._initOnceArgv();
        utility2.assert(state.aa === false, state.aa);
        utility2.assert(state.bb === 1, state.bb);
        utility2.assert(state.cc === true, state.cc);
        process.argv = ['--cc', 'bb'];
        state.modeCli = '';
        local._initOnceArgv();
        utility2.assert(state.cc === 'bb', state.cc);
        process.argv = ['--cc', '1'];
        local._initOnceArgv();
        utility2.assert(state.cc === 1, state.cc);
        process.argv = ['--no-cc'];
        local._initOnceArgv();
        utility2.assert(state.cc === false, state.cc);
        onEventError();
      });
    },

    _initOnceNpmTest: function () {
      /* test utility2 */
      if (state.modeNpmTest) {
        /* setTimeout so these listeners are added last, after other utility2 listeners */
        setTimeout(function () {
          /* exit with non-zero code if tests failed */
          process.on('exit', function () {
            if (state.testReportCopy && state.testReportCopy.testsFailed) {
              process.exit(1);
            }
          });
          /* exit with zero code on user interrupt */
          process.on('SIGINT', process.exit);
        });
      }
    },

    __initOnceNpmTest_default_test: function (onEventError) {
      /*
        this function tests _initOnceNpmTest's default handling behavior
      */
      utility2.testMock(onEventError, [
        [global, {
          process: { exit: null, on: function (mode, callback) {
            if (mode === 'exit') {
              callback();
            }
          } },
          setTimeout: utility2.callArg0,
          state: { testReportCopy: utility2.testReportMerge({}) }
        }]
      ], function (onEventError) {
        var exitCode;
        process.exit = function (_) {
          exitCode = _;
        };
        /* test null case handling behavior */
        state.modeNpmTest = null;
        local._initOnceNpmTest();
        utility2.assert(!exitCode, exitCode);
        /* test default handling behavior */
        state.modeNpmTest = true;
        local._initOnceNpmTest();
        utility2.assert(!exitCode, exitCode);
        /* test tests failed handling behavior */
        state.testReportCopy.testsFailed = 1;
        local._initOnceNpmTest();
        utility2.assert(exitCode, exitCode);
        onEventError();
      });
    },

    _initOnceTmpdir: function () {
      /* default state.tmpdir to empty string if boolean */
      state.tmpdir = typeof state.tmpdir === 'string' ? state.tmpdir : '';
      /* init state.tmpdir */
      state.tmpdir = required.path.resolve(state.tmpdir
        || required.os.tmpdir() + '/utility2.' + encodeURIComponent(process.cwd()));
      utility2.jsonLog('_initOnceTmpdir - creating tmpdir ' + state.tmpdir);
      if (!required.fs.existsSync(state.tmpdir + '/cache')) {
        utility2.jsonLog('creating cache dir ' + state.tmpdir + '/cache');
        /* create cache dir */
        utility2.fsMkdirpSync(state.tmpdir + '/cache');
      }
      /* cleanup old cache */
      required.fs.readdirSync(state.tmpdir + '/cache').forEach(function (file) {
        local._fsRmr(state.tmpdir + '/cache/' + file, utility2.onEventErrorDefault);
      });
      /* periodically remove cache files */
      utility2.unref(utility2.clearCallSetInterval('_fsCacheCleanup', function () {
        local._fsCacheCleanup(utility2.onEventErrorDefault);
      }, 300000));
    },

    __initOnceTmpdir_default_test: function (onEventError) {
      /*
        this function tests _initOnceTmpdir's default handling behavior
      */
      var data;
      utility2.testMock(onEventError, [
        [global, { state: {} }],
        [local, { _fsCacheCleanup: utility2.nop, _fsRmr: utility2.nop }],
        [required.fs, {
          existsSync: utility2.nop,
          readdirSync: function () {
            return [null];
          }
        } ],
        [utility2, { clearCallSetInterval: utility2.callArg1 }]
      ], function (onEventError) {
        /* test state.tmpdir does not exist handling behavior */
        local._initOnceTmpdir();
        data = utility2.jsonStringifyOrdered(state);
        /* validate state */
        utility2.assert(data === JSON.stringify({ tmpdir: required.path.resolve(
          required.os.tmpdir() + '/utility2.' + encodeURIComponent(process.cwd())
        )}), data);
        /* test state.tmpdir exists handling behavior */
        required.fs.existsSync = function () {
          return true;
        };
        local._initOnceTmpdir();
        data = utility2.jsonStringifyOrdered(state);
        /* validate state */
        utility2.assert(data === JSON.stringify({ tmpdir: required.path.resolve(
          required.os.tmpdir() + '/utility2.' + encodeURIComponent(process.cwd())
        )}), data);
        onEventError();
      });
    },

    createStreamReadableMock: function (data) {
      /*
        this function creates a mock readable stream around the given data
      */
      var self;
      self = new local._StreamReadableMock();
      required.stream.Readable.call(self);
      self.data = data;
      return self;
    },

    _fsCacheCleanup: function (onEventError) {
      /*
        this function cleans up the cachedir
      */
      var dir, mode, onEventError2;
      mode = 0;
      onEventError2 = function (error, data) {
        mode = utility2.modeIncrement(error, mode);
        switch (mode) {
        case 1:
          /* loop through state._fsCacheCleanupFileList */
          dir = state.tmpdir + '/cache';
          utility2.jsonLog('_fsCacheCleanup - cleaning ' + dir);
          state._fsCacheCleanupFileList = state._fsCacheCleanupFileList || [];
          state._fsCacheCleanupFileList.forEach(onEventError2);
          mode += 1;
          onEventError2();
          break;
        case 2:
          /* rm -r cached dir / file */
          mode -= 1;
          local._fsRmr(dir + '/' + error, utility2.onEventErrorDefault);
          break;
        case 3:
          /* get list of files to be removed for the next cycle */
          required.fs.readdir(dir, onEventError2);
          break;
        case 4:
          /* save list to state._fsCacheCleanupFileList */
          state._fsCacheCleanupFileList = data;
          onEventError2();
          break;
        default:
          onEventError(error);
        }
      };
      onEventError2();
    },

    __fsCacheCleanup_default_test: function (onEventError) {
      /*
        this function tests _fsCacheCleanup's default handling behavior
      */
      var dir, mode, onEventError2;
      mode = 0;
      onEventError2 = function (error) {
        mode = utility2.modeIncrement(error, mode);
        switch (mode) {
        case 1:
          /* create dummy dir for removal */
          dir = state.tmpdir + '/cache/' + utility2.uuid4();
          required.fs.mkdir(dir, onEventError2);
          break;
        case 2:
          /* create dummy file in dummy dir */
          required.fs.writeFile(
            dir + '/__fsCacheCleanup_default_test',
            '__fsCacheCleanup_default_test',
            onEventError2
          );
          break;
        case 3:
          /* add dummy dir to cleanup list */
          state._fsCacheCleanupFileList = [required.path.basename(dir)];
          /* remove dummy dir */
          local._fsCacheCleanup(onEventError2);
          break;
        default:
          onEventError(error);
        }
      };
      onEventError2();
    },

    __fsCacheCleanup_error_test: function (onEventError) {
      /*
        this function tests _fsCacheCleanup's error handling behavior
      */
      utility2.testMock(onEventError, [
        [global, {
          local: { _fsRmr: utility2.nop },
          required: { fs: { readdir: utility2.callError1, unlink: utility2.callArg1 } }
        }]
      ], function (onEventError) {
        local._fsCacheCleanup(function (error) {
          /* assert error occurred */
          utility2.assert(error instanceof Error, error);
          onEventError();
        });
      });
    },

    fsMkdirp: function (dir, onEventError) {
      /*
        this function recursively builds up nested directories as necessary
      */
      var mode, onEventError2;
      mode = 0;
      onEventError2 = function (error) {
        mode = utility2.modeIncrement(error, mode);
        switch (mode) {
        /* attempt to mkdir */
        case 1:
          required.fs.mkdir(dir, onEventError2);
          break;
        /* mkdir successful */
        case 2:
          onEventError();
          break;
        /* mkdir failed */
        default:
          switch (error && error.code) {
          /* dir already exists - fallback to success */
          case 'EEXIST':
            onEventError();
            break;
          /* parent dir doesn't exist - recurse up parent dir */
          case 'ENOENT':
            mode = 0;
            utility2.fsMkdirp(required.path.dirname(dir), onEventError2);
            break;
          /* default error */
          default:
            onEventError(error);
          }
        }
      };
      onEventError2();
    },

    _fsMkdirp_default_test: function (onEventError) {
      /*
        this function tests fsMkdirp's default handling behavior
      */
      var dir, mode, onEventError2;
      mode = 0;
      onEventError2 = function (error) {
        mode = utility2.modeIncrement(error, mode);
        switch (mode) {
        case 1:
          /* test default handling behavior */
          dir = state.tmpdir + '/cache/' + utility2.uuid4() + '/' + utility2.uuid4();
          utility2.fsMkdirp(dir, onEventError2);
          break;
        case 2:
          /* test EEXIST handling behavior */
          utility2.fsMkdirp(dir, onEventError2);
          break;
        case 3:
          /* assert dir exists */
          required.fs.exists(dir, utility2.tryCatchHandler(onEventError2));
          break;
        case 4:
          /* assert file exists */
          utility2.assert(error, error);
          onEventError2();
          break;
        default:
          onEventError(error);
        }
      };
      onEventError2();
    },

    _fsMkdirp_error_test: function (onEventError) {
      /*
        this function tests fsMkdirp's error handling behavior
      */
      utility2.fsMkdirp('/dev/null/_fsMkdirp_error_test', function (error) {
        utility2.tryCatch(function () {
          /* assert error occurred */
          utility2.assert(error instanceof Error, error);
          onEventError();
        }, onEventError);
      });
    },

    fsMkdirpSync: function (dir) {
      /*
        this function recursively builds up nested directories as necessary
      */
      utility2.tryCatch(function () {
        required.fs.mkdirSync(dir);
      }, function (error) {
        switch (error.code) {
        case 'EEXIST':
          break;
        case 'ENOENT':
          utility2.fsMkdirpSync(required.path.dirname(dir));
          utility2.fsMkdirpSync(dir);
          break;
        default:
          throw error;
        }
      });
    },

    _fsMkdirpSync_default_test: function (onEventError) {
      /*
        this function tests fsMkdirpSync's default handling behavior
      */
      var dir;
      dir = state.tmpdir + '/cache/' + utility2.uuid4() + '/' + utility2.uuid4();
      utility2.fsMkdirpSync(dir);
      /* mkdir a second time to trigger EEXIST case */
      utility2.fsMkdirpSync(dir);
      required.fs.exists(dir, function (exists) {
        utility2.assert(exists, exists);
        onEventError();
      });
    },

    _fsMkdirpSync_error_test: function (onEventError) {
      /*
        this function tests fsMkdirpSync's error handling behavior
      */
      utility2.tryCatch(function () {
        utility2.fsMkdirpSync('/dev/null/foo');
      }, function (error) {
        /* assert error occurred */
        utility2.assert(error instanceof Error, error);
        onEventError();
      });
    },

    _fsRmr: function (dir, onEventError) {
      /*
        this function recursively removes the dir
      */
      var mode, onEventReady, onEventError2;
      mode = 0;
      onEventError2 = function (error, data) {
        /* ignore ENOENT error - since file doesn't exist, rm was technically successful */
        error = error && error.code === 'ENOENT' ? null : error;
        mode = error instanceof Error && mode !== 1 ? -1 : mode + 1;
        switch (mode) {
        case 1:
          /* common case - try to unlink dir if its a regular file */
          required.fs.unlink(dir, onEventError2);
          break;
        case 2:
          /* if error occurred, then its a dir */
          if (error) {
            /* readdir dir and recursively apply _fsRmr to its files */
            required.fs.readdir(dir, onEventError2);
            return;
          }
          /* else file unlink successful */
          onEventError();
          break;
        case 3:
          onEventReady = utility2.untilReady(onEventError2);
          (data || []).forEach(function (file) {
            onEventReady.remaining += 1;
            local._fsRmr(dir + '/' + file, onEventReady);
          });
          /* handle empty dir case */
          onEventReady.remaining += 1;
          onEventReady();
          break;
        case 4:
          required.fs.rmdir(dir, onEventError2);
          break;
        default:
          onEventError(error);
        }
      };
      onEventError2();
    },

    __fsRmr_error_test: function (onEventError) {
      /*
        this function tests _fsRmr's error handling behavior
      */
      utility2.testMock(onEventError, [
        [required, { fs: {} }]
      ], function (onEventError) {
        required.fs.readdir = utility2.callArg1;
        required.fs.rmdir = required.fs.unlink = utility2.callError1;
        local._fsRmr(state.tmpdir + '/cache/' + utility2.uuid4(), function (error) {
          utility2.tryCatch(function () {
            /* assert error occurred */
            utility2.assert(error instanceof Error, error);
            onEventError();
          }, onEventError);
        });
      });
    },

    __fsRmr_errorEnoent_test: function (onEventError) {
      /*
        this function tests _fsRmr's ENOENT error handling behavior
      */
      local._fsRmr(state.tmpdir + '/cache/' + utility2.uuid4(), onEventError);
    },

    fsWatch: function (options) {
      /*
        this function watches a file and evals it if it's modified
      */
      var onEventChange;
      onEventChange = function (stat2, stat1) {
        var data;
        if (stat2.mtime < stat1.mtime) {
          return;
        }
        data = required.fs.readFileSync(options.file, 'utf8');
        /* save content to options dict */
        options.content = required.path.extname(options.file) === '.js'
          ? utility2.scriptInstrument(options.file, data)
          : data;
        /* run actions */
        options.actionList.forEach(function (action) {
          state.fsWatchActionDict[action](options);
        });
        /* auto-generate browser content, stripped of nodejs code */
        state.fsWatchActionDict.createContentBrowser(options);
      };
      options.file = required.path.resolve(options.file);
      /* save options to state.fsWatchDict */
      state.fsWatchDict[options.file] = options;
      /* unwatch old stale file */
      required.fs.unwatchFile(options.file);
      /* watch the new file */
      required.fs.watchFile(options.file, { interval: 1000, persistent: false }, onEventChange);
      /* synchronously eval the file */
      onEventChange({ mtime: 2 }, { mtime: 1 });
    },

    fsWatchActionDict_base64Decode: function (options) {
      /*
        this function base64Decodes the file content into a binary blob
      */
      options.content = new Buffer(options.content, 'base64');
    },

    fsWatchActionDict_createContentBrowser: function (options) {
      /*
        this function caches the file content for browser use, stripping it of nodejs code
      */
      if (Buffer.isBuffer(options.content) || required.path.extname(options.file) !== '.js') {
        options.contentBrowser = options.content;
        return;
      }
      /* additional processing for javascript content */
      /* remove nodejs modules */
      options.contentBrowser = options.content.replace(
        (/^\(function module\w*Nodejs\(\) \{[\S\s]*?^\}\(\)\);$/gm),
        function (match) {
          return match.replace((/.*/g), '');
        }
      ).trimRight();
    },

    fsWatchActionDict_eval: function (options) {
      /*
        this function evals the file content
      */
      switch (required.path.extname(options.file)) {
      /* eval js file */
      case '.js':
        utility2.evalOnEventError(options.file, options.content, function (error) {
          utility2.onEventErrorDefault(error);
        });
        break;
      /* eval js2 file */
      case '.js2':
        options.content.replace(
          (/^\/\* MODULE_BEGIN (.+) \*\/$([\S\s]+?)^\/\* MODULE_END \*\/$/gm),
          function (_, options2, content, ii) {
            utility2.nop(_);
            options2 = JSON.parse(options2);
            /* save options2 to state.fsWatchDict */
            state.fsWatchDict[options2.file] = options2;
            /* save content to options2 dict */
            options2.content
              /* preserve lineno */
              = options.content.slice(0, ii).replace(/.*/g, '') + content;
            /* instrument js file */
            if (required.path.extname(options2.file) === '.js') {
              options2.content
                = utility2.scriptInstrument(options.file, options2.content);
            }
            /* run actions */
            options2.actionList.forEach(function (action) {
              state.fsWatchActionDict[action](options2);
            });
            /* auto-generate browser content, stripped of nodejs code */
            state.fsWatchActionDict.createContentBrowser(options2);
          }
        );
        break;
      }
    },

    fsWatchActionDict_lint: function (options) {
      /*
        this function css / js lints the file content
      */
      utility2.scriptLint(options.file, options.content);
    },

    fsWatchActionDict_trim: function (options) {
      /*
        this function trims the file content
      */
      options.content = options.content.trim();
    },

    fsWriteFileAtomic: function (file, data, onEventError) {
      /*
        this function will
        1. write the data to a unique cache file
        2. rename the cache file to persistent file
        3. mkdirp parent dir if necessary
      */
      var mode, onEventError2, tmp;
      utility2.assert(state.tmpdir, 'fsWriteFileAtomic - invalid state.tmpdir ' + state.tmpdir);
      mode = 0;
      onEventError2 = function (error) {
        mode = utility2.modeIncrement(error, mode);
        switch (mode) {
        /* 1. write the data to a cache file */
        case 1:
          tmp = state.tmpdir + '/cache/' + utility2.uuid4();
          required.fs.writeFile(tmp, data, onEventError2);
          break;
        /* 2. rename the cache file to persistent file */
        case 2:
          required.fs.rename(tmp, file, onEventError2);
          break;
        default:
          /* 3. mkdirp parent dir if necessary */
          if (error && error.code === 'ENOENT') {
            mode = 1;
            utility2.fsMkdirp(required.path.dirname(file), onEventError2);
            return;
          }
          onEventError(error);
        }
      };
      onEventError2();
    },

    _fsWriteFileAtomic_default_test: function (onEventError) {
      /*
        this function tests fsWriteFileAtomic's and friends' default handling behavior
      */
      var file, mode, onEventError2;
      mode = 0;
      onEventError2 = function (error, data) {
        mode = utility2.modeIncrement(error, mode);
        switch (mode) {
        case 1:
          /* test fsWriteFileAtomic's default handling behavior */
          file = state.tmpdir + '/cache/' + utility2.uuid4();
          utility2.fsWriteFileAtomic(file, '_fsWriteFileAtomic_default_test', onEventError2);
          break;
        case 2:
          required.fs.readFile(file, 'utf8', onEventError2);
          break;
        case 3:
          utility2.assert(data === '_fsWriteFileAtomic_default_test', data);
          onEventError2();
          break;
        default:
          onEventError(error);
        }
      };
      onEventError2();
    },

    headlessPhantomjs: function (options, onEventError) {
      /*
        this function starts a separate phantomjs process to open and test a webpage
      */
      var onEventError2, testCallbackId, timeout;
      onEventError2 = function (error) {
        /* clear timeout for headlessPhantomjs */
        clearTimeout(timeout);
        /* garbage collect testCallbackId */
        delete state.testCallbackDict[testCallbackId];
        onEventError(error);
      };
      testCallbackId = utility2.uuid4();
      options.url = utility2.textFormat(options.url, {
        localhost: state.localhost,
        testCallbackId: testCallbackId,
        timeoutDefault: state.timeoutDefault
      });
      state.phantomjs = utility2.shell({ argv: [
        options.argv0 || (utility2.__dirname + '/.install/phantomjs/bin/phantomjs'),
        utility2.__filename,
        new Buffer(JSON.stringify(options)).toString('base64')
      ], modeDebug: false });
      state.testCallbackDict[testCallbackId] = onEventError2;
      /* set timeout for headlessPhantomjs */
      timeout = utility2.onEventTimeout(
        onEventError2,
        state.timeoutDefault,
        'headlessPhantomjs ' + options.url
      );
    },

    _headlessPhantomjs_default_test: function (onEventError) {
      /*
        this function tests headlessPhantomjs's default handling behavior
      */
      utility2.headlessPhantomjs({
        url: '{{localhost}}/test/test.html'
          + '?testCallbackId={{testCallbackId}}#modeTest=1'
          + '&testReportUpload=1&timeoutDefault={{timeoutDefault}}'
      }, onEventError);
    },

    modeCliDict_npmInstall: function () {
      /*
        this function installs files from utility2.js2 to the .install dir
      */
      var mode, onEventError2, onEventReady;
      mode = 0;
      onEventError2 = function (_, data) {
        utility2.nop(_);
        mode += 1;
        switch (mode) {
        case 1:
          /* update utility2 from specified branch */
          if (state.modeUtility2Update) {
            utility2.jsonLog('npmInstall - updating ' + utility2.__dirname + ' from branch '
              + state.modeUtility2Update);
            required.fs.readdir(utility2.__dirname, onEventError2);
            return;
          }
          mode += 1;
          onEventError2();
          break;
        case 2:
          onEventReady = utility2.untilReady(onEventError2);
          onEventReady.remaining += data.length;
          /* loop through dir list and update each file from github */
          data.forEach(function (file) {
            var url;
            url = 'https://raw.githubusercontent.com/kaizhu256/utility2/'
              + state.modeUtility2Update + '/' + file;
            /* fetch file from github */
            utility2.ajax({ url: url }, function (error, data) {
              if (error) {
                /* ignore error likely due to non-existent remote file */
                onEventReady();
                return;
              }
              utility2.jsonLog('npmInstall - fetched ' + url);
              /* update local file with fetched data */
              required.fs.writeFile(utility2.__dirname + '/' + file, data, onEventReady);
            });
          });
          break;
        case 3:
          /* loop through cached files in state.fsWatchDict and install if necessary */
          Object.keys(state.fsWatchDict).forEach(function (file) {
            if ((/^(?:\.gitignore|\.install|Procfile|\/public)\b/).test(file)) {
              /* install file to .install dir */
              required.fs.writeFile(
                process.cwd() + '/' + file,
                state.fsWatchDict[file].contentBrowser,
                utility2.onEventErrorDefault
              );
            }
          });
          break;
        }
      };
      onEventError2();
    },

    _modeCliDict_npmInstall_default_test: function (onEventError) {
      /*
        this function tests modeCliDict_npmInstall's default handling behavior
      */
      utility2.testMock(onEventError, [
        [global, {
          required: { fs: {
            readdir: function (_, onEventError) {
              utility2.nop(_);
              onEventError(null, [null]);
            },
            writeFile: utility2.nop
          } },
          state: {
            fsWatchDict: state.fsWatchDict,
            modeCli: 'npmInstall',
            modeCliDict: state.modeCliDict,
            modeUtility2Update: 'master'
          }
        }],
        [utility2, { ajax: utility2.callArg1 }]
      ], function (onEventError) {
        /* test state.modeUtility2Update enabled handling behavior */
        state.modeCliDict[state.modeCli]();
        /* test state.modeUtility2Update enabled with error handling behavior */
        utility2.ajax = utility2.callError1;
        state.modeCliDict[state.modeCli]();
        /* test state.modeUtility2Update disabled handling behavior */
        state.modeUtility2Update = null;
        state.modeCliDict[state.modeCli]();
        onEventError();
      });
    },

    modeCliDict_testReportMerge: function () {
      /*
        this function creates a merged testReport from .build/test-report.json
      */
      state.modeTestReportMerge = true;
      utility2.testReportNodejs(utility2.testReportMerge({}));
    },

    _modeCliDict_testReportMerge_default_test: function (onEventError) {
      /*
        this function tests modeCliDict_testReportMerge's default handling behavior
      */
      utility2.testMock(onEventError, [
        [global, { state: { modeCli: 'testReportMerge', modeCliDict: state.modeCliDict } }],
        [utility2, { testReportNodejs: utility2.nop }]
      ], function (onEventError) {
        state.modeCliDict[state.modeCli]();
        /* assert state.modeTestReportMerge is true */
        utility2.assert(state.modeTestReportMerge, state.modeTestReportMerge);
        onEventError();
      });
    },

    _readyUtility2Exit_error_test: function (onEventError) {
      /*
        this function tests readyUtility2Exit's error handling behavior
      */
      utility2.testMock(onEventError, [
        [global, { process: { exit: null } }],
        [utility2, { onEventErrorDefault: utility2.nop }],
        [utility2.readyUtility2Exit, { error: null, remaining: 0 }]
      ], function (onEventError) {
        process.exit = function (error) {
          utility2.tryCatch(function () {
            utility2.assert(error === true, error);
            onEventError();
          }, onEventError);
        };
        utility2.readyUtility2Exit.remaining += 1;
        utility2.readyUtility2Exit(utility2.error);
      });
    },

    replParse: function (script) {
      /*
        this function parses repl stdin
      */
      var arg1, arg2;
      /* null -> "(null\n)" */
      if (!/^\(.*\n\)$/.test(script)) {
        return script;
      }
      script = script.slice(1, -2);
      /* @@ syntax sugar */
      while (/\w@@ /.test(script)) {
        script = script.replace(/(\w)@@ ([\S\s]*)/, '$1($2)');
      }
      arg1 = script.split(' ');
      arg2 = arg1.slice(1).join(' ');
      arg1 = arg1[0];
      if (state.replParseDict[arg1]) {
        return state.replParseDict[arg1](arg2);
      }
      return '(' + script + '\n)';
    },

    _replParse_default_test: function (onEventError) {
      /*
        this function tests replParse's default handling behavior
      */
      /*jslint evil: true*/
      utility2.testMock(onEventError, [
        [utility2, { evalOnEventError: utility2.nop }]
      ], function (onEventError) {
        /* test syntax error */
        state.repl.eval('syntax error');
        /* test '@@' syntax sugar */
        state.repl.eval('(console.log@@ "_replParse_default_test"\n)');
        onEventError();
      });
    },

    replParseDict_$: function (arg2) {
      /*
        this function runs shell commands from the repl interpreter
      */
      utility2.shell({ modeDebug: false, script: utility2.textFormat(arg2, state) });
    },

    _replParseDict_$_default_test: function (onEventError) {
      /*
        this function tests replParseDict_$'s default handling behavior
      */
      utility2.testMock(onEventError, [
        [utility2, { shell: utility2.nop }]
      ], function (onEventError) {
        utility2.replParse('($ echo "_replParseDict_print_default_test"\n)');
        onEventError();
      });
    },

    replParseDict_git: function (arg2) {
      /*
        this function runs git commands from the repl interpreter
      */
      switch (arg2) {
      case 'diff':
        arg2 = '--no-pager diff';
        break;
      case 'log':
        arg2 = 'log | head -n 18';
        break;
      }
      utility2.shell({ modeDebug: false, script: 'git ' + arg2 });
    },

    _replParseDict_git_default_test: function (onEventError) {
      /*
        this function tests replParseDict_git's default handling behavior
      */
      utility2.testMock(onEventError, [
        [utility2, { shell: utility2.nop }]
      ], function (onEventError) {
        utility2.replParse('(git diff\n)');
        utility2.replParse('(git log\n)');
        utility2.replParse('(git status\n)');
        onEventError();
      });
    },

    replParseDict_grep: function (arg2) {
      /*
        this function performs grep searches from the repl interpreter
      */
      utility2.shell({ modeDebug: false, script: 'find . -type f | grep -v '
        + '"/\\.\\|.*\\b\\(\\.\\d\\|archive\\|artifacts\\|bower_components\\|build'
        + '\\|coverage\\|docs\\|external\\|git_modules\\|jquery\\|log\\|logs\\|min'
        + '\\|node_modules\\|rollup.*\\|swp\\|test\\|tmp\\)\\b" '
        + '| tr "\\n" "\\000" | xargs -0 grep -in ' + JSON.stringify(arg2) });
    },

    _replParseDict_grep_default_test: function (onEventError) {
      /*
        this function tests replParseDict_grep's default handling behavior
      */
      utility2.testMock(onEventError, [
        [utility2, { shell: utility2.nop }]
      ], function (onEventError) {
        utility2.replParse('(grep "_replParseDict_grep_default_test"\n)');
        onEventError();
      });
    },

    replParseDict_print: function (arg2) {
      /*
        this function prints arg2 in stringified form from the repl interpreter
      */
      return '(console.log(String(' + arg2 + '))\n)';
    },

    _replParseDict_print_default_test: function (onEventError) {
      /*
        this function tests replParseDict_print's default handling behavior
      */
      utility2.testMock(onEventError, [
      ], function (onEventError) {
        utility2.replParse('(print "_replParseDict_print_default_test"\n)');
        onEventError();
      });
    },

    shell: function (options) {
      /*
        this function executes shell scripts with timeout handling
      */
      var child, timeout;
      options.stdio = options.stdio || ['ignore', 1, 2];
      /* spawn shell in child process */
      child = required.child_process.spawn(
        options.argv ? options.argv[0] : '/bin/bash',
        options.argv ? options.argv.slice(1) : ['-c', options.script],
        options
      );
      /* set timeout for shell */
      timeout = utility2.unref(required.child_process.spawn('/bin/bash', ['-c', 'sleep '
        + ((options.timeout || state.timeoutDefault) / 1000) + '; kill ' + child.pid
        + ' 2>/dev/null'], { stdio: 'ignore' })).pid;
      /* debug shell exit code */
      child
        .on('error', utility2.onEventErrorDefault)
        .on('exit', function (exitCode) {
          try {
            /* kill timeout process */
            process.kill(timeout);
          } catch (ignore) {
          }
          utility2.jsonLog('shell - process ' + child.pid + ' exited with code ' + exitCode);
        });
      /* debug shell options */
      if (options.modeDebug !== false) {
        utility2.jsonLog('shell - options', options);
      }
      return child;
    },

    _shell_default_test: function (onEventError) {
      /*
        this function tests shell's default handling behavior
      */
      utility2.testMock(onEventError, [
      ], function (onEventError) {
        local.shell({ script: ':' }).on('exit', onEventError);
      });
    },

    _StreamReadableMock: function () {
      /*
        this is the _StreamReadableMock class
      */
      return;
    },

    _StreamReadableMock_prototype__read: function () {
      /*
        this function is StreamReadableMock's mandatory _read implementation
        for the readable stream class
      */
      if (!this.pushed) {
        this.pushed = true;
        this.push(this.data);
        return;
      }
      this.push(null);
    },

    streamReadAll: function (readableStream, onEventError) {
      /*
        this function concats data from readable stream and passes it to callback when done
      */
      var chunks;
      chunks = [];
      /* read data from readable stream */
      readableStream.on('data', function (chunk) {
        chunks.push(chunk);
      /* call callback when finished reading */
      }).on('end', function () {
        onEventError(null, Buffer.concat(chunks));
      /* pass any errors to the callback */
      }).on('error', onEventError);
    },

    _streamReadAll_default_test: function (onEventError) {
      /*
        this function tests streamReadAll's default handling behavior
      */
      utility2.streamReadAll(
        utility2.createStreamReadableMock('_streamReadAll_default_test'),
        function (error, data) {
          utility2.tryCatch(function () {
            /* assert no error occurred */
            utility2.assert(!error, error);
            data = data.toString();
            utility2.assert(data === '_streamReadAll_default_test', data);
            onEventError();
          }, onEventError);
        }
      );
    },

    testReportNodejs: function (testReport) {
      /*
        this function runs extra test reporting code for nodejs
      */
      var mode, onEventError2, onEventReady;
      mode = 0;
      onEventError2 = function (error, data) {
        mode += 1;
        switch (mode) {
        case 1:
          if (state.modeTestReportMerge) {
            required.fs.readFile(
              state.builddir + '/test-report.json',
              utility2.jsonParseHandler(onEventError2)
            );
            return;
          }
          mode += 1;
          onEventError2();
          break;
        case 2:
          /* ignore error */
          utility2.nop(error);
          /* merge previous data into current testReport */
          utility2.testReportMerge(testReport, data);
          utility2.testReportLog(testReport);
          onEventError2();
          break;
        case 3:
          /* mkdir testReport */
          utility2.fsMkdirp(state.builddir, onEventError2);
          break;
        case 4:
          onEventReady = state.modeNpmTest
            ? utility2.readyUtility2Exit
            : utility2.untilReady(utility2.onEventErrorDefault);
          /* write test-report.badge.svg */
          onEventReady.remaining += 3;
          required.fs.writeFile(
            state.builddir + '/test-report.badge.svg',
            local._testReportNodejsBadge(testReport),
            onEventReady
          );
          /* write test-report.html */
          utility2.jsonLog('\ncreating test report file://' + state.builddir
            + '/test-report.html');
          required.fs.writeFile(
            state.builddir + '/test-report.html',
            utility2.testReportHtml(testReport),
            onEventReady
          );
          /* write test-report.json */
          required.fs.writeFile(
            state.builddir + '/test-report.json',
            JSON.stringify(testReport, null, 2),
            onEventReady
          );
          break;
        }
      };
      onEventError2();
    },

    _testReportNodejs_default_test: function (onEventError) {
      /*
        this function tests testReportNodejs's default handling behavior
      */
      utility2.testMock(onEventError, [
        [global, { state: {
          /* test onEventErrorDefault handling behavior */
          modeNpmTest: false,
          /* test state.modeTestReportMerge handling behavior */
          modeTestReportMerge: true
        } }],
        [local, { _testReportNodejsBadge: utility2.nop }],
        [required, { fs: { readFile: utility2.callArg1, writeFile: utility2.callArg2 } }],
        [utility2, { fsMkdirp: utility2.callArg1, testReportHtml: utility2.nop }]
      ], function (onEventError) {
        /* test state.modeTestReportMerge enabled handling behavior */
        utility2.testReportNodejs({});
        /* test state.modeTestReportMerge disabled handling behavior */
        state.modeTestReportMerge = null;
        utility2.testReportNodejs({});
        onEventError();
      });
    },

    _testReportNodejsBadge: function (testReport) {
      /*
        this function creates a test report summary badge
      */
      return state.fsWatchDict['/test/modeAjaxOffline/https%3A%2F%2Fimg.shields.io'
        + '%2Fbadge%2Ftests_failed-999-dd0000.svg%3Fstyle%3Dflat%23GET'].contentBrowser
        .replace('999', testReport.testsFailed)
        .replace('d00', testReport.testsFailed ? 'd00' : '0d0');
    },

    __testReportNodejsBadge_default_test: function (onEventError) {
      /*
        this function tests _testReportNodejsBadge's default handling behavior
      */
      var data;
      /* test tests passed handling behavior */
      data = local._testReportNodejsBadge({ testsFailed: 0 });
      utility2.assert(data.indexOf('#0d0') >= 0, data);
      /* test tests failed handling behavior */
      data = local._testReportNodejsBadge({ testsFailed: 1 });
      utility2.assert(data.indexOf('#d00') >= 0, data);
      onEventError();
    },

    _textToCamelCase: function (text) {
      /*
        this function converts dashed names to camel case
      */
      return text.replace((/[\-_][a-z]/g), function (match) {
        return match[1].toUpperCase();
      });
    },

    __textToCamelCase_default_test: function (onEventError) {
      /*
        this function tests _textToCamelCase's default handling behavior
      */
      var data;
      data = local._textToCamelCase('');
      utility2.assert(data === '', data);
      data = local._textToCamelCase('aa-bb-cc');
      utility2.assert(data === 'aaBbCc', data);
      onEventError();
    },

    _utility2_timeout_test: function (onEventError) {
      /*
        this function tests utility2's timeout handling behavior
      */
      var timeout;
      utility2.shell({ argv: [utility2.__filename, '--no-mode-test'], modeDebug: false })
        .on('exit', function (exitCode) {
          utility2.tryCatch(function () {
            /* clear timeout for _utility2_timeout_test */
            clearTimeout(timeout);
            /* assert exit code is zero */
            utility2.assert(exitCode === 0, exitCode);
            onEventError();
          }, onEventError);
        });
      /* assert utility2 child process exits in a relatively small time-frame */
      timeout = utility2.onEventTimeout(
        onEventError,
        8000,
        '_utility2_timeout_test'
      );
    }

  };
  local._init();
}());



(function moduleAjaxBrowser() {
  /*
    this browser module exports the ajax api
  */
  'use strict';
  var local;
  local = {

    _name: 'utility2.moduleAjaxBrowser',

    _init: function () {
      if (state.modeBrowser) {
        utility2.initLocal(local);
      }
    },

    _initOnce: function () {
      /* init ajaxProgressDiv element */
      local._initOnceAjaxProgressDiv(global, local);
      local._ajaxProgressDiv.innerHTML = '<div class="ajaxProgressBarDiv'
        + ' ajaxProgressBarDivLoading">loading</div>';
      /* init ajaxProgressBarDiv element */
      local._ajaxProgressBarDiv = local._ajaxProgressDiv
        .getElementsByClassName('ajaxProgressBarDiv')[0];
      /* reset progres bar */
      local._ajaxProgressHide();
      /* abort all pending ajax request on click event */
      local._ajaxProgressDiv.addEventListener('click', local._ajaxProgressAbort);
      /* create global setInterval to check ajax progress */
      /* and hide the progress bar if necessary */
      utility2.clearCallSetInterval('ajaxProgressDivHide', function () {
        if (local._ajaxProgressList.length === 0
            && local._ajaxProgressDiv.style.display !== 'none') {
          /* display progress status for a short time before hiding */
          setTimeout(local._ajaxProgressHide, 1000);
        }
      }, 1000);
    },

    _initOnceAjaxProgressDiv: function (global2, local2) {
      /* init ajaxProgressDiv element */
      local2._ajaxProgressDiv = global2.document.getElementById('ajaxProgressDiv')
        || global2.document.createElement('div');
    },

    _initOnceAjaxProgressDiv_progressDisabled_test: function (onEventError) {
      /*
        this function tests _initOnceAjaxProgressDiv's progress disabled handling behavior
      */
      local._initOnceAjaxProgressDiv({ document: {
        getElementById: utility2.nop,
        createElement: function (data) {
          utility2.assert(data === 'div', data);
          onEventError();
        }
      } }, {});
    },

    ajaxBrowser: function (options, onEventError) {
      /*
        this function implements the the ajax function for the browser
      */
      var data, error, ii, onEventEvent, onEventError2, timeout, xhr;
      /* error handling */
      onEventError2 = function (error, data) {
        if (error) {
          /* add extra debug info to error */
          utility2.ajaxErrorDebug(
            error,
            options.method,
            xhr.status,
            options.url,
            xhr.responseText
          );
        }
        onEventError(error, data);
      };
      /* event handling */
      onEventEvent = function (event) {
        switch (event.type) {
        case 'abort':
        case 'error':
        case 'load':
          /* clear timeout for ajaxBrowser */
          clearTimeout(timeout);
          /* remove xhr from progress list */
          ii = local._ajaxProgressList.indexOf(xhr);
          if (ii >= 0) {
            local._ajaxProgressList.splice(ii, 1);
          }
          if (!error) {
            /* handle abort or error event */
            if (event.type !== 'load' || xhr.status >= 400) {
              error = new Error(event.type);
            /* handle text data */
            } else {
              data = xhr.responseText;
            }
          }
          onEventError2(error, data);
          break;
        }
        /* increment progress bar */
        if (local._ajaxProgressList.length !== 0) {
          local._ajaxProgressIncrement();
          return;
        }
        /* finish progress bar */
        switch (event.type) {
        case 'load':
          local._ajaxProgressUpdate('100%', 'ajaxProgressBarDivSuccess', 'loaded');
          break;
        default:
          local._ajaxProgressUpdate('100%', 'ajaxProgressBarDivError', event.type);
        }
      };
      /* init xhr object */
      xhr = new XMLHttpRequest();
      /* xhr event handling */
      xhr.addEventListener('abort', onEventEvent);
      xhr.addEventListener('error', onEventEvent);
      xhr.addEventListener('load', onEventEvent);
      xhr.addEventListener('loadstart', local._ajaxProgressIncrement);
      xhr.addEventListener('progress', local._ajaxProgressIncrement);
      xhr.upload.addEventListener('progress', local._ajaxProgressIncrement);
      /* set timeout for ajaxBrowser */
      timeout = utility2.onEventTimeout(function (timeout) {
        error = timeout;
        xhr.abort();
      }, state.timeoutDefault, 'ajaxBrowser');
      /* display progress bar if hidden */
      if (local._ajaxProgressList.length === 0) {
        local._ajaxProgressDiv.style.display = 'block';
      }
      local._ajaxProgressList.push(xhr);
      /* open url in xhr */
      xhr.open(options.method, options.url);
      /* send data through xhr */
      xhr.send(options.data);
    },

    _ajaxBrowser_progressAbort_test: function (onEventError) {
      /*
        this function tests ajaxBrowser's progress abort handling behavior
      */
      utility2.testMock(onEventError, [
        [local, { _ajaxProgressList: [] }],
        [global, {
          setTimeout: utility2.nop,
          state: {},
          XMLHttpRequest: function () {
            var self;
            self = this;
            utility2.setOverride(self, {
              addEventListener: function (eventType, onEventEvent) {
                state[eventType] = onEventEvent;
              },
              open: utility2.nop,
              send: utility2.nop,
              upload: { addEventListener: utility2.nop }
            });
          }
        }]
      ], function (onEventError) {
        utility2.ajax({ url: '/test/test.json' }, function (error) {
          /* assert error occurred */
          utility2.assert(error instanceof Error, error);
          onEventError();
        });
        /* test missing xhr handling behavior */
        local._ajaxProgressList.length = 0;
        state.abort({ type: 'abort' });
      });
    },

    _ajaxBrowser_progressFinish_test: function (onEventError) {
      /*
        this function tests ajaxBrowser's progress finish handling behavior
      */
      var intervalId, mode, onEventError2;
      mode = 0;
      onEventError2 = function (error) {
        mode = utility2.modeIncrement(error, mode);
        switch (mode) {
        case 1:
          /* wait for other ajax tests to init first */
          setTimeout(onEventError2);
          break;
        case 2:
          /* set interval */
          intervalId = utility2.uuid4();
          utility2.clearCallSetInterval(
            intervalId,
            utility2.tryCatchHandler(onEventError2),
            2000,
            /* halve timeout to make sure its not blocking other ajax tests */
            0.5 * state.timeoutDefault
          );
          break;
        case 3:
          mode -= 1;
          /* assert no error occurred */
          utility2.assert(!error, error);
          /* wait until progress has successfully finished */
          if (local._ajaxProgressList.length === 0
              && local._ajaxProgressDiv.style.display === 'none') {
            mode += 1;
            onEventError2();
          }
          break;
        default:
          /* clear interval */
          utility2.clearCallSetInterval(intervalId, 'clear');
          onEventError(error);
        }
      };
      onEventError2();
    },

    _ajaxBrowser_timeout_test: function (onEventError) {
      /*
        this function tests ajaxBrowser's timeout handling behavior
      */
      var self;
      utility2.testMock(onEventError, [
        [global, {
          /* mock xhr.abort */
          XMLHttpRequest: function () {
            self = this;
            utility2.setOverride(self, {
              abort: function () {
                self._abort({ type: 'abort' });
              },
              addEventListener: function (event, callback) {
                self['_' + event] = callback;
              },
              open: utility2.nop,
              send: utility2.nop,
              upload: { addEventListener: utility2.nop }
            });
          },
          setTimeout: utility2.callArg0
        }],
        [local, { _ajaxProgressList: [], _ajaxProgressUpdate: utility2.nop }]
      ], function (onEventError) {
        utility2.ajax({ url: '/test/test.json' }, function (error) {
          /* assert error occurred */
          utility2.assert(error instanceof Error, error);
          /* assert error is timeout error */
          utility2.assert(error.code === 'ETIMEDOUT', error.code);
          onEventError();
        });
      });
    },

    _ajaxProgressAbort: function () {
      /*
        this function aborts all pending ajax requests
      */
      while (local._ajaxProgressList.length) {
        local._ajaxProgressList.pop().abort();
      }
    },

    __ajaxProgressAbort_default_test: function (onEventError) {
      /*
        this function tests _ajaxProgressAbort's default handling behavior
      */
      utility2.testMock(onEventError, [
        [local, { _ajaxProgressList: [{}] }]
      ], function (onEventError) {
        local._ajaxProgressList[0].abort = onEventError;
        local._ajaxProgressAbort();
      });
    },

    _ajaxProgressHide: function () {
      /*
        this function hides the progress bar if all ajax request are finished
      */
      if (local._ajaxProgressList.length === 0) {
        /* hide progress bar */
        local._ajaxProgressDiv.style.display = 'none';
        /* reset progress state */
        local._ajaxProgressState = 0;
        local._ajaxProgressUpdate('0%', 'ajaxProgressBarDivLoading', 'loading');
      }
    },

    __ajaxProgressHide_default_test: function (onEventError) {
      /*
        this function tests _ajaxProgressHide's default handling behavior
      */
      utility2.testMock(onEventError, [
        [local, {
          _ajaxProgressDiv: { style: { display: 'block' } },
          _ajaxProgressBarDiv: { className: '', style: {} },
          _ajaxProgressList: [],
          _ajaxProgressState: 0
        }]
      ], function (onEventError) {
        /* test nop handling behavior */
        local._ajaxProgressList.push(null);
        local._ajaxProgressHide();
        utility2.assert(
          local._ajaxProgressDiv.style.display === 'block',
          local._ajaxProgressDiv.style.display
        );
        /* test hide progress bar handling behavior */
        local._ajaxProgressList.length = 0;
        local._ajaxProgressHide();
        utility2.assert(
          local._ajaxProgressDiv.style.display === 'none',
          local._ajaxProgressDiv.style.display
        );
        onEventError();
      });
    },

    _ajaxProgressIncrement: function () {
      /*
        this function increments the progress bar
      */
      /* this algorithm can indefinitely increment the progress bar */
      /* with successively smaller increments without ever reaching 100% */
      local._ajaxProgressState += 1;
      local._ajaxProgressUpdate(
        100 - 75 * Math.exp(-0.125 * local._ajaxProgressState) + '%',
        'ajaxProgressBarDivLoading',
        'loading'
      );
    },

    _ajaxProgressList: [],

    _ajaxProgressUpdate: function (width, type, label) {
      /*
        this function visually updates the progress bar
      */
      local._ajaxProgressBarDiv.style.width = width;
      local._ajaxProgressBarDiv.className = local._ajaxProgressBarDiv.className
        .replace((/ajaxProgressBarDiv\w+/), type);
      local._ajaxProgressBarDiv.innerHTML = label;
    }

  };
  local._init();
}());



(function moduleAjaxNodejs() {
  /*
    this nodejs module exports the ajax api
  */
  'use strict';
  var local;
  local = {

    _name: 'utility2.moduleAjaxNodejs',

    _init: function () {
      if (state.modeNodejs) {
        utility2.initLocal(local);
      }
    },

    _ajaxCache: function (options, onEventError) {
      /*
        this function tries to get the data from local cache instead of running the ajax request
      */
      /* cache all ajax request */
      if (state.modeAjaxOffline) {
        options.cache = options.cache || 'miss';
        options.cachePrefix = options.cachePrefix || '/modeAjaxOffline';
      }
      options.cachePrefix = options.cachePrefix || '/cache/ajax';
      if (options.cache && options.cache !== 'miss') {
        required.fs.readFile(state.tmpdir + '/' + options.cachePrefix + '/'
          + encodeURIComponent(options.url0 + '#' + options.method), function (error, data) {
            if (error) {
              options.cache = 'miss';
              utility2.ajax(options, onEventError);
              return;
            }
            options.cache = 'hit';
            local._ajaxOnEventData(options, onEventError, null, data);
          });
        return true;
      }
    },

    __ajaxCache_default_test: function (onEventError) {
      /*
        this function tests _ajaxCache's default handling behavior
      */
      var mode, onEventError2, options;
      mode = 0;
      onEventError2 = function (error) {
        mode = utility2.modeIncrement(error, mode);
        switch (mode) {
        /* test cache miss handling behavior */
        case 1:
          options = { cache: true, url: '/test/test.json?' + utility2.uuid4() };
          utility2.ajax(options, utility2.tryCatchHandler(onEventError2));
          break;
        case 2:
          /* assert no error occurred */
          utility2.assert(!error, error);
          utility2.assert(options.cache === 'miss', options);
          onEventError2();
          break;
        /* test cache hit handling behavior */
        case 3:
          options.cache = true;
          setTimeout(onEventError2, 1000);
          break;
        case 4:
          utility2.ajax(options, utility2.tryCatchHandler(onEventError2));
          break;
        case 5:
          /* assert no error occurred */
          utility2.assert(!error, error);
          utility2.assert(options.cache === 'hit', options);
          onEventError2();
          break;
        default:
          onEventError(error);
        }
      };
      onEventError2();
    },

    __ajaxCache_modeAjaxOffline_test: function (onEventError) {
      /*
        this function tests _ajaxCache's modeAjaxOffline handling behavior
      */
      utility2.testMock(onEventError, [
        [global, { state: { modeAjaxOffline: true } }]
      ], function (onEventError) {
        var options;
        options = {};
        local._ajaxCache(options);
        utility2.assert(utility2.jsonStringifyOrdered(options)
          === '{"cache":"miss","cachePrefix":"/modeAjaxOffline"}', options);
        onEventError();
      });
    },

    ajaxNodejs: function (options, onEventError) {
      /*
        this function implements the the ajax function for nodejs
      */
      var onEventError2, remaining, request, response, timeout, urlParsed;
      onEventError2 = function (error, data) {
        /* clear timeout for ajaxNodejs */
        clearTimeout(timeout);
        if (error) {
          /* add extra debug info to error */
          utility2.ajaxErrorDebug(
            error,
            options.method,
            response && response.statusCode,
            options.url,
            ''
          );
          /* garbage collect request socket */
          if (request) {
            request.destroy();
          }
          /* garbage collect response socket */
          if (response) {
            response.destroy();
          }
        }
        /* debug mode option */
        if (options.modeDebug) {
          utility2.jsonLog('ajaxNodejs - response', [
            options.url,
            options.responseStatusCode,
            options.responseHeaders
          ]);
        }
        remaining -= 1;
        /* ignore responses after timeout */
        if (remaining === 0) {
          onEventError(error, data);
        }
      };
      remaining = 1;
      /* set timeout for ajaxNodejs */
      timeout = utility2.onEventTimeout(onEventError2, state.timeoutDefault, 'ajaxNodejs');
      /* localhost */
      if (options.url[0] === '/') {
        options.url = state.localhost + options.url;
      }
      /* assert valid http / https url */
      if (!(/^https*:/).test(options.url)) {
        onEventError2(new Error('ajaxNodejs - invalid url ' + options.url));
        return;
      }
      /* ajax caching */
      if (local._ajaxCache(options, onEventError2)) {
        return;
      }
      /* use cached data when in local mode */
      if (state.modeOffline && options.url.indexOf(state.localhost) !== 0) {
        options.url = state.localhost + '/test/modeAjaxOffline/'
          + encodeURIComponent(options.url + '#' + options.method);
      }
      /* set default options */
      urlParsed = required.url.parse(String(options.url));
      /* bug - disable socket pooling, because it causes timeout errors in tls tests */
      options.agent = options.agent || false;
      /* host needed for redirects */
      options.host = urlParsed.host;
      /* hostname needed for http(s).request */
      options.hostname = urlParsed.hostname;
      /* path needed for http(s).request */
      options.path = urlParsed.path;
      /* port needed for http(s).request */
      options.port = urlParsed.port;
      /* protocol needed for http(s).request */
      options.protocol = urlParsed.protocol;
      /* run ajax request */
      request = (options.protocol === 'https:'
        ? required.https
        : required.http).request(options, function (_) {
        response = _;
        local._ajaxOnEventResponse(options, onEventError2, response);
      });
      /* error handling */
      request.on('error', onEventError2);
      /* debug ajaxRequest */
      state.debugAjaxRequest = request;
      /* pipe request */
      if (options.data instanceof required.stream.Readable) {
        options.data.on('error', onEventError2).pipe(request.on('error', onEventError2));
      /* end request */
      } else {
        request.end(options.data);
      }
      /* debug mode option */
      if (options.modeDebug) {
        utility2.jsonLog('ajaxNodejs - options', options);
      }
    },

    _ajaxNodejs_timeout_test: function (onEventError) {
      /*
        this function tests ajaxNodejs's timeout handling behavior
      */
      utility2.testMock(onEventError, [
        [global, { setTimeout: utility2.callArg0 }]
      ], function (onEventError) {
        utility2.ajax({ url: '/test/test.json' }, function (error) {
          /* assert error occurred */
          utility2.assert(error instanceof Error, error);
          /* assert error is timeout error */
          utility2.assert(error.code === 'ETIMEDOUT', error.code);
          onEventError();
        });
      });
    },

    _ajaxNodejs_https_test: function (onEventError) {
      /*
        this function tests ajaxNodejs's https handling behavior
      */
      utility2.testMock(onEventError, [
        [required, { https: { request: function () {
          return { end: utility2.nop, on: utility2.nop };
        } } }],
        [state, { modeOffline: false }]
      ], function (onEventError) {
        utility2.ajax({ url: 'https://_ajaxNodejs_https_test' }, function (error) {
          utility2.tryCatch(function () {
            /* assert error occurred */
            utility2.assert(error instanceof Error, error);
            onEventError();
          }, onEventError);
        });
      });
    },

    _ajaxNodejs_invalidUrl_test: function (onEventError) {
      /*
        this function tests ajaxNodejs's invalid url handling behavior
      */
      utility2.ajax({ url: '_ajaxNodejs_invalidUrl_test' }, function (error) {
        utility2.tryCatch(function () {
          /* assert error occurred */
          utility2.assert(error instanceof Error, error);
          onEventError();
        }, onEventError);
      });
    },

    _ajaxNodejs_modeOffline_test: function (onEventError) {
      /*
        this function tests ajaxNodejs's modeOffline handling behavior
      */
      utility2.testMock(onEventError, [
        [global, { setTimeout: setTimeout }],
        [state, { modeOffline: true }]
      ], function (onEventError) {
        var options;
        options = { url: 'https://img.shields.io/badge/coverage-100.0%-00dd00.svg?style=flat' };
        utility2.ajax(options, function (error) {
          utility2.tryCatch(function () {
            /* assert no error occurred */
            utility2.assert(!error, error);
            utility2.assert(options.url === state.localhost + '/test/modeAjaxOffline/'
              + 'https%3A%2F%2Fimg.shields.io%2Fbadge%2Fcoverage-100.0%25-00dd00.svg'
              + '%3Fstyle%3Dflat%23GET', options.url);
            onEventError();
          }, onEventError);
        });
      });
    },

    _ajaxOnEventData: function (options, onEventError, error, data) {
      /*
        this function handles error / data received by ajax request
      */
      if (error) {
        onEventError(error);
        return;
      }
      if (options.responseStatusCode >= 400) {
        onEventError(new Error(data.toString()));
        return;
      }
      /* cache data */
      if (options.cache === 'miss') {
        utility2.fsWriteFileAtomic(state.tmpdir + '/' + options.cachePrefix + '/'
          + encodeURIComponent(options.url0
            + '#' + options.method), data, utility2.onEventErrorDefault);
      }
      onEventError(null, options.resultType === 'binary' ? data : data.toString());
    },

    __ajaxOnEventData_default_test: function (onEventError) {
      /*
        this function tests _ajaxOnEventData's default handling behavior
      */
      var onEventReady;
      onEventReady = utility2.untilReady(onEventError);
      onEventReady.remaining += 3;
      /* test default handling behavior */
      utility2.ajax({
        url: '/test/test.json'
      }, function (error, data) {
        utility2.tryCatch(function () {
          /* assert no error occurred */
          utility2.assert(!error, error);
          utility2.assert(data === '"hello test"', data);
          onEventReady();
        }, onEventReady);
      });
      /* test binary resultType handling behavior */
      utility2.ajax({
        resultType: 'binary',
        url: '/test/test.json'
      }, function (error, data) {
        utility2.tryCatch(function () {
          /* assert no error occurred */
          utility2.assert(!error, error);
          utility2.assert(data.toString() === '"hello test"', data);
          onEventReady();
        }, onEventReady);
      });
      /* test error handling behavior */
      local._ajaxOnEventData(null, function (error) {
        utility2.tryCatch(function () {
          /* assert error occurred */
          utility2.assert(error instanceof Error, error);
          onEventReady();
        }, onEventReady);
      }, utility2.error);
    },

    _ajaxOnEventResponse: function (options, onEventError, response) {
      /*
        this function handles the response object received by ajax request
      */
      /* error handling */
      response.on('error', onEventError);
      /* debug response */
      state.debugAjaxResponse = response;
      if (options.resultType === 'response') {
        onEventError(null, response);
        return;
      }
      options.responseStatusCode = response.statusCode;
      options.responseHeaders = response.headers;
      if (options.redirect !== false) {
        switch (response.statusCode) {
        /* 3xx redirect */
        case 301:
        case 302:
        case 303:
        case 304:
        case 305:
        case 306:
        case 307:
          options.redirected = options.redirected || 0;
          options.redirected += 1;
          if (options.redirected >= 8) {
            onEventError(new Error('ajaxNodejs - too many http redirects to '
              + response.headers.location));
            return;
          }
          options.url = response.headers.location;
          if (options.url && options.url[0] === '/') {
            options.url = options.protocol + '//' + options.host + options.url;
          }
          utility2.ajax(options, onEventError);
          return;
        }
      }
      utility2.streamReadAll(
        response.on('error', onEventError),
        function (error, data) {
          local._ajaxOnEventData(options, onEventError, error, data);
        }
      );
    },

    __ajaxOnEventResponse_redirect_test: function (onEventError) {
      /*
        this function tests _ajaxOnEventResponse's redirect handling behavior
      */
      utility2.testMock(onEventError, [
        [utility2, { ajax: utility2.callArg1, streamReadAll: utility2.nop }]
      ], function (onEventError) {
        /* test default redirect handling behavior */
        local._ajaxOnEventResponse({}, function (error) {
          /* assert no error occurred */
          utility2.assert(!error, error);
        }, { headers: {}, on: utility2.nop, statusCode: 301 });
        /* test too many redirects handling behavior */
        local._ajaxOnEventResponse({ redirected: Infinity }, function (error) {
          /* assert error occurred */
          utility2.assert(error instanceof Error, error);
        }, { headers: {}, on: utility2.nop, statusCode: 301 });
        /* test redirect disabled handling behavior */
        local._ajaxOnEventResponse({ redirect: false}, null, { on: utility2.nop });
        onEventError();
      });
    },

    replParseDict_ajax: function (arg2) {
      /*
        this function runs ajax from the repl interpreter
      */
      utility2.ajax({ modeDebug: true, url: arg2 }, utility2.onEventErrorDefault);
    },

    _replParseDict_ajax_default_test: function (onEventError) {
      /*
        this function tests replParseDict_ajax's default handling behavior
      */
      utility2.testMock(onEventError, [
        [utility2, { ajax: utility2.nop }]
      ], function (onEventError) {
        utility2.replParse('(ajax /test/test.json\n)');
        onEventError();
      });
    }

  };
  local._init();
}());



(function moduleAjaxShared() {
  /*
    this shared module exports the ajax api
  */
  'use strict';
  var local;
  local = {

    _name: 'utility2.moduleAjaxShared',

    _init: function () {
      utility2.initLocal(local);
    },

    ajax: function (options, onEventError) {
      /*
        this function runs the ajax request, and auto-concats the response stream into utf8 text
      */
      /* validate options */
      if (!(options && typeof options.url === 'string')) {
        onEventError(new Error('ajax - invalid options.url ' + (options && options.url)));
        return;
      }
      /* assert callback is a function */
      utility2.assert(
        typeof onEventError === 'function',
        'invalid onEventError ' + typeof onEventError
      );
      /* set options.headers if necessary */
      options.headers = options.headers || {};
      /* set options.url0 if necessary */
      options.url0 = options.url0 || options.url;
      /* set options.method if necessary */
      if (options.data) {
        options.method = options.method || 'POST';
      }
      options.method = options.method || 'GET';
      (state.modeNodejs ? utility2.ajaxNodejs : utility2.ajaxBrowser)(options, onEventError);
    },

    _ajax_default_test: function (onEventError) {
      /*
        this function tests ajax's default handling behavior
      */
      utility2.ajax({ modeDebug: true, url: '/' }, onEventError);
    },

    _ajax_nullCase_test: function (onEventError) {
      /*
        this function tests ajax's null case handling behavior
      */
      utility2.ajax({}, function (error, data) {
        utility2.tryCatch(function () {
          /* assert error occurred */
          utility2.assert(error instanceof Error, error);
          utility2.assert(data === undefined, data);
          onEventError();
        }, onEventError);
      });
    },

    ajaxErrorDebug: function (error, method, statusCode, url, data) {
      /*
        this function add extra ajax debug info to the error's message and stack
      */
      /* add http method / status / url info to error.message */
      error.message = method + ' ' + statusCode + ' - ' + url
        + '\n' + error.message + '\n' + data;
      if (error.stack) {
        /* bug - phantomjs has readonly error.stack */
        utility2.tryCatch(function () {
          error.stack = error.message + '\n' + error.stack;
        }, utility2.nop);
      }
    },

    ajaxMultiUrls: function (options, onEventReady) {
      /*
        this function makes multiple ajax requests for multiple urls
      */
      var remainingList;
      /* validate options.urlList */
      if (!(options
        && Array.isArray(options.urlList)
        && options.urlList.every(function (url) {
            return typeof url === 'string';
          }))) {
        onEventReady(new Error('ajaxMultiUrls - invalid options.urlList '
          + utility2.jsonStringifyCircular(options && options.urlList)));
        return;
      }
      remainingList = utility2.jsonCopy(options.urlList);
      options.urlList.forEach(function (url) {
        var options2;
        options2 = utility2.jsonCopy(options);
        options2.url = url;
        utility2.ajax(options2, function (error, data) {
          /* debug remainingList */
          remainingList.splice(remainingList.indexOf(options2.url0), 1);
          utility2.jsonLog('ajaxMultiUrls - fetched / remaining', [
            options2.url0,
            JSON.stringify(remainingList.slice(0, 2)).replace(']', ',...]')
          ]);
          onEventReady(error, {
            data: data,
            options: options2
          });
        });
      });
    },

    _ajaxMultiUrls_default_test: function (onEventError) {
      /*
        this function tests ajaxMultiUrls's default handling behavior
      */
      var onEventReady;
      onEventReady = utility2.untilReady(onEventError);
      onEventReady.remaining += 2;
      utility2.ajaxMultiUrls({ urlList: [
        '/test/test.json',
        (state.localhost || '') + '/test/test.json'
      ] }, function (error, data) {
        utility2.tryCatch(function () {
          /* assert no error occurred */
          utility2.assert(!error, error);
          utility2.assert(data.data === '"hello test"', data.data);
          onEventReady();
        }, onEventReady);
      });
    },

    _ajaxMultiUrls_error_test: function (onEventError) {
      /*
        this function tests ajaxMultiUrls's error handling behavior
      */
      utility2.ajaxMultiUrls({ urlList: [null] }, function (error) {
        utility2.tryCatch(function () {
          /* assert error occurred */
          utility2.assert(error instanceof Error, error);
          onEventError();
        }, onEventError);
      });
    },

    _ajaxMultiUrls_nullCase_test: function (onEventError) {
      /*
        this function tests ajaxMultiUrls's null case handling behavior
      */
      utility2.ajaxMultiUrls(null, function (error) {
        utility2.tryCatch(function () {
          /* assert error occurred */
          utility2.assert(error instanceof Error, error);
          onEventError();
        }, onEventError);
      });
    }

  };
  local._init();
}());



(function moduleGithubNodejs() {
  /*
    this nodejs module exports the github api
  */
  'use strict';
  var local;
  local = {

    _name: 'utility2.moduleGithubNodejs',

    _init: function () {
      if (state.modeGithub
          && state.modeNodejs
          && process.env.GITHUB_TOKEN) {
        utility2.initLocal(local);
        state.githubDefault = state.githubDefault
          || local._createGithub(state.modeGithub, process.env.GITHUB_TOKEN);
      }
    },

    _blobSha: function (blob) {
      /*
        this function calculates the blob's sha hash
      */
      return required.crypto.createHash('sha1')
        .update('blob ' + blob.length + '\x00')
        .update(blob)
        .digest('hex');
    },

    _Branch: function () {
      /*
        this is the _Branch class
      */
      return;
    },

    __Branch_default_test: function (onEventError) {
      /*
        this function tests _Branch's default handling behavior
      */
      var file, mode, onEventError2, self;
      self = state.githubDefault;
      mode = 0;
      onEventError2 = function (error) {
        mode = utility2.modeIncrement(error, mode);
        switch (mode) {
        case 1:
          /* test _Branch_prototype_fileDelete's null handling behavior */
          file = '/test/_Branch_default_test.json';
          self.fileDelete(file, onEventError2);
          break;
        case 2:
          /* test _Branch_prototype_fileUpdate's default handling behavior */
          self.fileUpdate(file, new Buffer('"_Branch_default_test"'), onEventError2);
          break;
        case 3:
          /* test _Branch_prototype_fileUpdate's sha hash comparison handling behavior */
          self.fileUpdate(file, new Buffer('"_Branch_default_test"'), onEventError2);
          break;
        case 4:
          /* test _Branch_prototype_fileDelete's null handling behavior */
          self.fileDelete(file + utility2.uuid4(), onEventError2);
          break;
        case 5:
          /* test _Branch_prototype_fileDelete's default handling behavior */
          self.fileDelete(file, onEventError2);
          break;
        default:
          onEventError(error);
        }
      };
      onEventError2();
    },

    __Branch_error_test: function (onEventError) {
      /*
        this function tests _Branch's error handling behavior
      */
      utility2.testMock(onEventError, [
        /* ajax error handling behavior */
        [utility2, { ajax: utility2.callError1 }]
      ], function (onEventError) {
        var onEventReady, self;
        onEventReady = utility2.untilReady(onEventError);
        onEventReady.remaining += 4;
        self = state.githubDefault;
        /* test _Branch_prototype_fileDelete's error handling behavior */
        self.fileDelete(null, function (error) {
          utility2.tryCatch(function () {
            /* assert error occurred */
            utility2.assert(error instanceof Error, error);
            onEventReady();
          }, onEventReady);
        });
        /* test _Branch_prototype_fileSha's error handling behavior */
        self.fileSha(null, function (error) {
          utility2.tryCatch(function () {
            /* assert error occurred */
            utility2.assert(error instanceof Error, error);
            onEventReady();
          }, onEventReady);
        });
        /* test _Branch_prototype_fileUpdate's error handling behavior */
        self.fileUpdate(null, null, function (error) {
          utility2.tryCatch(function () {
            /* assert error occurred */
            utility2.assert(error instanceof Error, error);
            onEventReady();
          }, onEventReady);
        });
        /* test _Branch_prototype_fileSha's 404 error handling behavior */
        utility2.ajax = function (_, onEventError) {
          utility2.nop(_);
          onEventError(new Error('GET 404'));
        };
        self.fileSha(null, function (error, data) {
          utility2.tryCatch(function () {
            /* assert no error occurred */
            utility2.assert(!error, error);
            utility2.assert(!data, data);
            onEventReady();
          }, onEventReady);
        });
      });
    },

    _Branch_prototype_ajax: function (options, onEventError) {
      /*
        this function makes an ajax request
      */
      utility2.ajax(utility2.setOverride(options, { headers: {
        authorization: 'token ' + this.token,
        /* data is always a string, so we use Buffer.byteLength */
        'content-length': options.data ? Buffer.byteLength(options.data) : 0,
        /* BUG - github api requires user-agent header */
        'user-agent': 'unknown'
      } }), utility2.jsonParseHandler(onEventError));
    },

    _Branch_prototype_branchMerge: function (other, commitMessage, onEventError) {
      /*
        this function merges the other branch into the current branch
      */
      this.ajax({
        data: JSON.stringify({
          base: this.branch,
          commit_message: commitMessage || undefined,
          head: other
        }),
        url: this.url + '/merges'
      }, onEventError);
    },

    __Branch_prototype_branchMerge_default_test: function (onEventError) {
      /*
        this function tests _Branch_prototype_branchMerge's default handling behavior
      */
      var self;
      self = state.githubDefault;
      utility2.testMock(onEventError, [
        [self, { ajax: utility2.callArg1 }]
      ], function (onEventError) {
        self.branchMerge('other', null, function (error) {
          utility2.tryCatch(function () {
            /* assert no error occurred */
            utility2.assert(!error, error);
            onEventError();
          }, onEventError);
        });
      });
    },

    _Branch_prototype_dirUpdate: function (dir, dirLocal, onEventError) {
      /*
        this function updates the entire github dir with the local dir
      */
      var file, fileList, mode, onEventError2, self;
      mode = 0;
      self = this;
      onEventError2 = function (error, data) {
        mode = utility2.modeIncrement(error, mode);
        switch (mode) {
        case 1:
          /* readdir */
          required.fs.readdir(dirLocal, onEventError2);
          break;
        case 2:
          /* save result to fileList */
          fileList = data;
          onEventError2();
          break;
        case 3:
          /* wait a while for github database to reach consistency before updating again */
          setTimeout(onEventError2, 2000);
          break;
        case 4:
          if (fileList.length === 0) {
            mode = -2;
            onEventError2();
            return;
          }
          file = fileList.shift();
          mode -= 2;
          required.fs.readFile(dirLocal + '/' + file, function (error, data) {
            if (error) {
              self.dirUpdate(dir + '/' + file, dirLocal + '/' + file, onEventError2);
              return;
            }
            self.fileUpdate(dir + '/' + file, data, onEventError2);
          });
          break;
        default:
          onEventError(error);
        }
      };
      onEventError2();
    },

    __Branch_prototype_dirUpdate_default_test: function (onEventError) {
      /*
        this function tests _Branch_prototype_dirUpdate's default handling behavior
      */
      var self;
      self = state.githubDefault;
      utility2.testMock(onEventError, [
        [required.fs, {
          /* mock readdir as a synchronous io operation */
          readdir: function (dir, onEventError) {
            utility2.tryCatch(function () {
              onEventError(null, required.fs.readdirSync(dir));
            }, onEventError);
          },
          /* mock readFile as a synchronous io operation */
          readFile: function (file, onEventError) {
            utility2.tryCatch(function () {
              onEventError(null, required.fs.readFileSync(file));
            }, onEventError);
          }
        }],
        [self, { fileUpdate: utility2.callArg2 }]
      ], function (onEventError) {
        self.dirUpdate(
          '__Branch_prototype_dirUpdate_default_test',
          utility2.__dirname + '/.install',
          onEventError
        );
      });
    },

    _Branch_prototype_fileDelete: function (file, onEventError) {
      /*
        this function deletes the specified file
        https://developer.github.com/v3/repos/contents/#delete-a-file
      */
      var mode, onEventError2, self;
      mode = 0;
      self = this;
      onEventError2 = function (error, data) {
        mode = utility2.modeIncrement(error, mode);
        switch (mode) {
        case 1:
          /* get the file's sha id */
          self.fileSha(file, onEventError2);
          break;
        case 2:
          /* file doesn't exist, so no need to delete it */
          if (!data) {
            onEventError();
            return;
          }
          /* delete file on github */
          self.ajax({ data: JSON.stringify({
            branch: self.branch,
            message: '[skip ci] delete ' + file,
            sha: data
          }), method: 'DELETE', url: self.url + '/contents' + file }, onEventError2);
          break;
        default:
          onEventError(error);
        }
      };
      onEventError2();
    },

    _Branch_prototype_fileSha: function (file, onEventError) {
      /*
        this function gets the file's sha id on github
      */
      var mode, onEventError2, self, sha;
      mode = 0;
      self = this;
      onEventError2 = function (error, data) {
        mode = utility2.modeIncrement(error, mode);
        switch (mode) {
        case 1:
          self.ajax({
            url: self.url + '/contents' + required.path.dirname(file) + '?ref=' + self.branch
          }, onEventError2);
          break;
        case 2:
          file = required.path.basename(file);
          /* default sha to empty string */
          sha = '';
          data.some(onEventError2);
          mode += 1;
          onEventError2();
          break;
        case 3:
          mode -= 1;
          if (error.name === file) {
            sha = error.sha;
            return true;
          }
          break;
        default:
          onEventError((/^GET 404\b/).test(error && error.message) ? null : error, sha);
        }
      };
      onEventError2();
    },

    _Branch_prototype_fileUpdate: function (file, blob, onEventError) {
      /*
        this function updates the specified file with the given blob
        https://developer.github.com/v3/repos/contents/#update-a-file
      */
      var mode, onEventError2, self;
      mode = 0;
      self = this;
      onEventError2 = function (error, data) {
        mode = utility2.modeIncrement(error, mode);
        switch (mode) {
        /* get the file's sha id */
        case 1:
          self.fileSha(file, onEventError2);
          break;
        case 2:
          /* don't update if sha hash matches */
          if (data === local._blobSha(blob)) {
            onEventError2();
            return;
          }
          self.ajax({ data: JSON.stringify({
            branch: self.branch,
            content: blob.toString('base64'),
            message: (data ? '[skip ci] update ' : '[skip ci] create ') + file,
            sha: data
          }), method: 'PUT', url: self.url + '/contents' + file }, onEventError2);
          break;
        default:
          onEventError(error);
        }
      };
      onEventError2();
    },

    __Branch_prototype_fileUpdate_shaMatch_test: function (onEventError) {
      /*
        this function tests _Branch_prototype_fileUpdate's sha match handling behavior
      */
      var blob, self;
      blob = new Buffer(1);
      self = state.githubDefault;
      utility2.testMock(onEventError, [
        [self, { fileSha: function (_, onEventError) {
          utility2.nop(_);
          onEventError(null, local._blobSha(blob));
        } }]
      ], function (onEventError) {
        self.fileUpdate(null, blob, function (error) {
          utility2.tryCatch(function () {
            /* assert no error occurred */
            utility2.assert(!error, error);
            onEventError();
          }, onEventError);
        });
      });
    },

    __Branch_prototype_fileUpdate_createFile_test: function (onEventError) {
      /*
        this function tests _Branch_prototype_fileUpdate's create file handling behavior
      */
      var blob, self;
      blob = new Buffer(1);
      self = state.githubDefault;
      utility2.testMock(onEventError, [
        [self, { ajax: utility2.callArg1, fileSha: utility2.callArg1 }]
      ], function (onEventError) {
        self.fileUpdate(null, blob, function (error) {
          utility2.tryCatch(function () {
            /* assert no error occurred */
            utility2.assert(!error, error);
            onEventError();
          }, onEventError);
        });
      });
    },

    _createGithub: function (ownerRepoBranch, token) {
      /*
        this function creates a github object for storing files
      */
      var self;
      self = new local._Branch();
      ownerRepoBranch = ownerRepoBranch.split('/');
      self.branch = ownerRepoBranch[2];
      self.token = token;
      self.url = 'https://api.github.com/repos/'
        + ownerRepoBranch[0] + '/' + ownerRepoBranch[1];
      return self;
    },

    modeCliDict_githubDirUpdate: function () {
      /*
        this function deletes the file on github
      */
      utility2.jsonLog('updating dir https://github.com/'
        + state.modeGithub.replace(/([^\/]+$)/, 'tree/$1')
        + state.githubFile);
      utility2.readyUtility2Exit.remaining += 1;
      state.githubDefault.dirUpdate(
        state.githubFile,
        state.githubLocal,
        utility2.readyUtility2Exit
      );
    },

    modeCliDict_githubFileDelete: function () {
      /*
        this function deletes the file on github
      */
      utility2.jsonLog('deleting https://raw.githubusercontent.com/'
        + state.modeGithub
        + state.githubFile);
      utility2.readyUtility2Exit.remaining += 1;
      state.githubDefault.fileDelete(
        state.githubFile,
        utility2.readyUtility2Exit
      );
    },

    modeCliDict_githubFileUpdate: function () {
      /*
        this function updates the file on github
      */
      utility2.jsonLog('updating https://raw.githubusercontent.com/'
        + state.modeGithub
        + state.githubFile);
      utility2.readyUtility2Exit.remaining += 1;
      utility2.streamReadAll(process.stdin, function (error, data) {
        /* assert no error occurred */
        utility2.assert(!error, error);
        state.githubDefault.fileUpdate(
          state.githubFile,
          data,
          utility2.readyUtility2Exit
        );
      });
    },

    _modeCliDict_githubFileUpdate_default_test: function (onEventError) {
      /*
        this function tests modeCliDict_githubFileUpdate's default handling behavior
      */
      utility2.testMock(onEventError, [
        [state, { githubDefault: {
          branchMerge: utility2.nop,
          dirUpdate: utility2.nop,
          fileDelete: utility2.nop,
          fileUpdate: utility2.nop
        } }],
        [utility2, { readyUtility2Exit: {}, streamReadAll: utility2.callArg1 }]
      ], function (onEventError) {
        /* test dir update handling behavior */
        state.modeCliDict.githubDirUpdate();
        /* test file delete handling behavior */
        state.modeCliDict.githubFileDelete();
        /* test file update handling behavior */
        state.modeCliDict.githubFileUpdate();
        onEventError();
      });
    }

  };
  local._init();
}());



(function moduleHeadlessSaucelabsNodejs() {
  /*
    this nodejs module exports the saucelabs test api
  */
  'use strict';
  var local;
  local = {

    _name: 'utility2.moduleHeadlessSaucelabsNodejs',

    _init: function () {
      if (state.modeNodejs) {
        utility2.initLocal(local);
      }
    },

    _initOnce: function () {
      /* disable tests for this module */
      utility2.readyUtility2.remaining += 1;
      required.fs.exists('/tmp/.saucelabs.ready', function (exists) {
        /* disable / enable tests for this module */
        state.testModuleDict[local._name] = !!(state.modeOffline
          || (exists && process.env.SAUCE_ACCESS_KEY && process.env.SAUCE_USERNAME));
        process.env.SAUCE_USERNAME = state.modeOffline
          ? 'utility2-kaizhu256'
          : process.env.SAUCE_USERNAME;
        utility2.readyUtility2();
      });
    },

    __initOnce_default_test: function (onEventError) {
      /*
        this function tests _initOnce's default handling behavior
      */
      utility2.testMock(onEventError, [
        [console, { error: utility2.nop }],
        [global, {
          process: { env: { SAUCE_ACCESS_KEY: true, SAUCE_USERNAME: true } },
          state: { testModuleDict: {}, modeOffline: null }
        }],
        [required, { fs: { exists: function (_, callback) {
          utility2.nop(_);
          callback(true);
        } } }],
        [utility2, { readyUtility2: null }]
      ], function (onEventError) {
        utility2.readyUtility2 = utility2.untilReady(onEventError);
        local._initOnce();
      });
    },

    headlessSaucelabs: function (options, onEventError) {
      /*
        this function requests saucelabs to test a webpage
      */
      var completed,
        intervalId,
        mode,
        onEventError2,
        onEventReady,
        remainingDict,
        time,
        timeout;
      mode = 0;
      onEventError2 = function (error, data) {
        mode = utility2.modeIncrement(error, mode);
        switch (mode) {
        case 1:
          /* init saucelabs tests */
          intervalId = utility2.uuid4();
          data = JSON.stringify(utility2.setOverride(options, {
            build: process.env.CI_BUILD_NUMBER_SAUCELABS,
            framework: 'custom',
            /* reduce timeoutDefault to account for saucelabs startup time */
            /* bug - saucelabs only accepts integers for max-duration */
            'max-duration': Math.ceil(Math.max(0.00075 * state.timeoutDefault, 60)),
            url: utility2.textFormat(options.url
              || '{{localhost}}/test/test.html#modeTest=1&timeoutDefault={{timeoutDefault}}', {
                localhost: state.localhost,
                /* reduce timeoutDefault to account for max-duration */
                timeoutDefault: 0.5 * state.timeoutDefault
              })
          }));
          onEventReady = utility2.untilReady(function (error) {
            mode = -2;
            onEventError(error);
          });
          options = {
            data: data,
            headers: {
              authorization: 'Basic ' + new Buffer(process.env.SAUCE_USERNAME
                + ':' + process.env.SAUCE_ACCESS_KEY).toString('base64'),
              'content-length': Buffer.byteLength(data),
              'content-type': 'application/json'
            },
            /* platforms needed for later debugging */
            platforms: options.platforms,
            url: 'https://saucelabs.com/rest/v1/' + process.env.SAUCE_USERNAME + '/js-tests'
          };
          remainingDict = {};
          time = Date.now();
          /* set timeout for headlessSaucelabs */
          timeout = utility2.onEventTimeout(
            onEventError2,
            state.timeoutDefault,
            'headlessSaucelabs ' + options.url
          );
          utility2.ajax(
            utility2.jsonCopy(options),
            utility2.tryCatchHandler(utility2.jsonParseHandler(onEventError2))
          );
          break;
        case 2:
          /* parse initial saucelabs response */
          utility2.jsonLog('\nheadlessSaucelabs - tests started -', [options, data]);
          /* create remainingDict of test id's */
          data['js tests'].forEach(function (id) {
            /* increment onEventReady */
            onEventReady.remaining += 1;
            /* init remainingDict */
            remainingDict[id] = { id: id, platform: options.platforms[data] };
          });
          /* wait 30000 ms for saucelabs test to startup */
          (state.modeOffline ? utility2.callArg0 : setTimeout)(onEventError2, 30000);
          break;
        case 3:
          /* poll saucelabs for test status */
          utility2.clearCallSetInterval(intervalId, function () {
            data = JSON.stringify({ 'js tests': Object.keys(remainingDict) });
            utility2.setOverride(options, {
              data: data,
              headers: { 'content-length': Buffer.byteLength(data) },
              url: 'https://saucelabs.com/rest/v1/' + process.env.SAUCE_USERNAME
                + '/js-tests/status'
            });
            utility2.ajax(
              utility2.jsonCopy(options),
              utility2.tryCatchHandler(utility2.jsonParseHandler(onEventError2))
            );
          }, 10000, state.timeoutDefault - (Date.now() - time));
          break;
        case 4:
          /* check status of polled tests from saucelabs response */
          mode -= 1;
          utility2.jsonLog('\nheadlessSaucelabs - tests polled -', data);
          completed = completed || data.completed || (/error/).test(data.status);
          data['js tests'].forEach(function (data) {
            /* test finished - remove from remainingDict */
            if (data.result && data.result.testReport) {
              /* remove test from remainingDict */
              delete remainingDict[data.id];
              /* merge finished test into state.testReport */
              utility2.testReportMerge(state.testReport, data.result.testReport);
              onEventReady();
              return;
            }
            /* test undefined - saucelabs internal error - remove from remainingDict */
            if (completed || data.result || (/error/).test(data.status)) {
              /* remove test from remainingDict */
              delete remainingDict[data.id];
              /* record time elapsed */
              data.totalTime = Date.now() - time;
              /* try to recover test status */
              local._headlessSaucelabsRecover(
                new Error(JSON.stringify(data)),
                data,
                onEventReady
              );
              return;
            }
            /* test pending - update test status */
            remainingDict[data.id] = {
              id: data.id,
              job_id: data.job_id,
              platform: data.platform,
              status: data.status
            };
          });
          break;
        default:
          /* clear timeout for headlessSaucelabs */
          clearTimeout(timeout);
          /* clear interval for headlessSaucelabs */
          utility2.clearCallSetInterval(intervalId, 'clear');
          /* record time elapsed */
          time = Date.now() - time;
          /* handle non-test-related error */
          if (onEventReady.remaining === 0) {
            onEventReady.remaining += 1;
            onEventReady(error);
            return;
          }
          /* try to recover remaining tests */
          Object.keys(remainingDict).forEach(function (data) {
            data = remainingDict[data];
            data.totalTime = time;
            local._headlessSaucelabsRecover(error, data, onEventReady);
          });
        }
      };
      onEventError2();
    },

    _headlessSaucelabs_default_test: function (onEventError) {
      /*
        this function tests headlessSaucelabs's default handling behavior
      */
      utility2.headlessSaucelabs({
        /* https://saucelabs.com/platforms */
        platforms: [['linux', 'googlechrome', ''], ['linux', 'firefox', '']]
      }, function (error) {
        utility2.tryCatch(function () {
          /* assert no error occurred */
          utility2.assert(!error, error);
          onEventError();
        }, onEventError);
      });
    },

    _headlessSaucelabs_error_test: function (onEventError) {
      /*
        this function tests headlessSaucelabs's error handling behavior
      */
      var mode;
      mode = 0;
      utility2.testMock(onEventError, [
        [global, { setTimeout: utility2.callArg0, state: { testReport: {} } }],
        [local, { _headlessSaucelabsRecover: function (error, data, onEventError) {
          onEventError(error, data);
        } }],
        [utility2, {
          ajax: function (_, onEventError) {
            utility2.nop(_);
            mode += 1;
            switch (mode) {
            case 1:
              onEventError(null, { 'js tests': [0, 1, 2, 3]});
              break;
            case 2:
              onEventError(null, { 'js tests': [
                /* test test finished handling behavior */
                { id: 0, result: { testReport: {} } },
                /* test internal saucelabs error handling behavior */
                { id: 1, status: 'error' },
                /* test test pending handling behavior */
                { id: 2, status: 'pending' },
                /* test malformed data handling behavior */
                null
              ]});
              break;
            }
          },
          clearCallSetInterval: function (_, callback) {
            utility2.nop(_);
            if (typeof callback === 'function') {
              callback();
            }
          },
          onEventTimeout: utility2.nop
        }]
      ], function (onEventError) {
        utility2.headlessSaucelabs({
          /* https://saucelabs.com/platforms */
          platforms: [[], [], [], []]
        }, function (error) {
          utility2.tryCatch(function () {
            /* assert error occurred */
            utility2.assert(error instanceof Error, error);
          }, onEventError);
        });
        /* test ajax error handling behavior */
        utility2.ajax = utility2.callError1;
        utility2.headlessSaucelabs({}, function (error) {
          utility2.tryCatch(function () {
            /* assert error occurred */
            utility2.assert(error instanceof Error, error);
          }, onEventError);
        });
        onEventError();
      });
    },

    _headlessSaucelabsRecover: function (error, testReport, onEventError) {
      /*
        this function tries to recover the testReport from saucelabs internal errors
      */
      var jobId, mode, onEventError2;
      mode = 0;
      onEventError2 = function (_, data) {
        mode = utility2.modeIncrement(_, mode);
        switch (mode) {
        case 1:
          jobId = testReport.job_id;
          /* fetch saucelabs logs */
          utility2.ajax({
            url: 'https://saucelabs.com/jobs/' + jobId + '/log.json'
          }, utility2.tryCatchHandler(utility2.jsonParseHandler(onEventError2)));
          break;
        case 2:
          /* try to recover testReport from saucelabs logs */
          data.forEach(function (data) {
            testReport = (data && data.result && data.result.testReport) || testReport;
          });
          /* testReport recovery succeeded */
          if (testReport.testPlatformList) {
            error = null;
          }
          /* notify saucelabs of pass / fail test statue */
          data = '{"passed":' + !error + '}';
          utility2.ajax({
            data: data,
            headers: {
              authorization: 'Basic ' + new Buffer(process.env.SAUCE_USERNAME
                + ':' + process.env.SAUCE_ACCESS_KEY).toString('base64'),
              'content-length': Buffer.byteLength(data),
              'content-type': 'application/json'
            },
            method: 'PUT',
            url: 'https://saucelabs.com/rest/v1/' + process.env.SAUCE_USERNAME + '/jobs/'
              + jobId
          }, onEventError2);
          break;
        default:
          /* testReport recovery failed */
          if (error) {
            /* create a minimal testReport reporting saucelabs internal error */
            testReport = { testPlatformList: [{
              name: 'browser - saucelabs '
                + (testReport.platform || ['unknown user agent']).join(' '),
              testCaseList: [{
                errorMessage: utility2.errorStack(error),
                module: local._name,
                name: '_headlessSaucelabs_default_test',
                time: testReport.totalTime
              }],
              totalTIme: testReport.totalTime
            }] };
            testReport.errorMessageList
              = [testReport.testPlatformList[0].testCaseList[0].errorMessage];
          } else {
            utility2.jsonLog('_headlessSaucelabsRecover - recovered testReport for jobId '
              + jobId);
          }
          /* merge recovered testReport into state.testReport */
          utility2.testReportMerge(state.testReport, testReport);
          onEventError(error);
        }
      };
      onEventError2();
    },

    __headlessSaucelabsRecover_default_test: function (onEventError) {
      /*
        this function tests _headlessSaucelabsRecover's default handling behavior
      */
      var testReport;
      utility2.testMock(onEventError, [
        [global, { state: { testReport: {} } }],
        [utility2, { ajax: function (_, onEventError) {
          utility2.nop(_);
          onEventError(null, JSON.stringify([null, { result: { testReport: testReport } } ]));
        } }]
      ], function (onEventError) {
        /* test testReport recovery failed handling behavior */
        testReport = null;
        local._headlessSaucelabsRecover(utility2.error, {}, function (error) {
          /* assert error occurred */
          utility2.assert(error instanceof Error);
        });
        /* test testReport recovery success handling behavior */
        testReport = utility2.testReportMerge({});
        local._headlessSaucelabsRecover(utility2.error, {}, function (error) {
          /* assert no error occurred */
          utility2.assert(!error, error);
        });
        onEventError();
      });
    },

    modeCliDict_headlessSaucelabs: function () {
      /*
        this function runs saucelabs tests with the given json options piped from stdin
      */
      /* read saucelabs test options from stdin */
      utility2.streamReadAll(process.stdin, utility2.jsonParseHandler(function (error, data) {
        /* assert no error occurred */
        utility2.assert(!error, error);
        /* init state */
        state.testModuleDict[local._name] = true;
        utility2.setOverride(state, data.stateOverride);
        /* remove stateOverride param */
        delete data.stateOverride;
        utility2.initLocal({
          _headlessSaucelabs_browser_test: function (onEventError) {
            utility2.headlessSaucelabs(data, onEventError);
          },
          _name: local._name,
          _modeTest: true
        });
      }));
    },

    _modeCliDict_headlessSaucelabs_default_test: function (onEventError) {
      /*
        this function tests modeCliDict_headlessSaucelabs's default handling behavior
      */
      var onEventError2;
      utility2.testMock(onEventError, [
        [global, { state: { modeCliDict: state.modeCliDict, testModuleDict: {} } }],
        [utility2, {
          headlessSaucelabs: utility2.callArg1,
          initLocal: function (local2) {
            local2._headlessSaucelabs_browser_test(onEventError2);
          },
          streamReadAll: function (_, onEventError) {
            utility2.nop(_);
            onEventError(null, JSON.stringify({
              /* test stateOverride handling behavior */
              "stateOverride": {}
            }));
          }
        }]
      ], function (onEventError) {
        onEventError2 = onEventError;
        state.modeCliDict.headlessSaucelabs();
      });
    },

    modeCliDict_headlessSaucelabsPlatformsList: function () {
      /*
        this function runs saucelabs tests with the given json options piped from stdin
      */
      var mode, onEventError2, options;
      mode = 0;
      onEventError2 = function (error, data) {
        mode = utility2.modeIncrement(error, mode);
        switch (mode) {
        case 1:
          /* read saucelabs test options from stdin */
          utility2.streamReadAll(process.stdin, utility2.jsonParseHandler(onEventError2));
          break;
        case 2:
          options = data;
          /* warm up test url */
          utility2.ajax({
            url: utility2.textFormat(options.url, {
              localhost: state.localhost,
              timeoutDefault: 1
            })
          }, function () {
            /* ignore ajax errors */
            onEventError2();
          });
          break;
        case 3:
          /* run platform tests sequentially in shell */
          utility2.shell({
            timeout: options.platformsList.length * options.stateOverride.timeoutDefault,
            /* loop through platformsList */
            script: options.platformsList.map(function (platforms) {
              /* sleep 1 second between platform tests */
              /* to give saucelabs some breathing room */
              return "sleep 1 && echo '"
                + JSON.stringify(utility2.setOverride(utility2.jsonCopy(options), {
                  platforms: platforms,
                  platformsList: undefined
                })) + "' | " + utility2.__filename
                  + ' --mode-cli=headlessSaucelabs --mode-npm-test --mode-test-report-merge'
                  + ' --server-port=49221 --tmpdir=' + state.tmpdir;
            }).join(';')
          }).on('exit', onEventError2);
          break;
        default:
          utility2.readyUtility2Exit.remaining = 1;
          utility2.readyUtility2Exit(error);
        }
      };
      onEventError2();
    },

    _modeCliDict_headlessSaucelabsPlatformsList_default_test: function (onEventError) {
      /*
        this function tests modeCliDict_headlessSaucelabsPlatformsList's
        default handling behavior
      */
      var onEventError2;
      utility2.testMock(onEventError, [
        [utility2, {
          ajax: utility2.callArg1,
          readyUtility2Exit: function () {
            onEventError2();
          },
          shell: function () {
            return { on: utility2.callArg1 };
          },
          streamReadAll: function (_, onEventError) {
            utility2.nop(_);
            onEventError(null, JSON.stringify({
              platformsList: [[]],
              stateOverride: {},
              url: ''
            }));
          }
        }]
      ], function (onEventError) {
        onEventError2 = onEventError;
        state.modeCliDict.headlessSaucelabsPlatformsList();
      });
    }

  };
  local._init();
}());



(function moduleHeadlessSlimerjsNodejs() {
  /*
    this nodejs module exports the slimerjs test api
  */
  'use strict';
  var local;
  local = {

    _name: 'utility2.moduleHeadlessSlimerjsNodejs',

    _init: function () {
      if (state.modeNodejs) {
        utility2.initLocal(local);
      }
    },

    _initOnce: function () {
      var onEventError;
      onEventError = function (error) {
        /*
          this function disables tests for this module if slimerjs is not detected
        */
        state.testModuleDict[local._name] = !error;
        utility2.readyUtility2();
      };
      utility2.readyUtility2.remaining += 1;
      /* auto-detect slimerjs binary */
      required.child_process.spawn(
        utility2.__dirname + '/.install/slimerjs/slimerjs',
        ['--help'],
        { stdio: 'ignore' }
      )
        .on('error', onEventError)
        .on('exit', onEventError);
    },

    headlessSlimerjs: function (options, onEventError) {
      /*
        this function starts a separate slimerjs process to open and test a webpage
      */
      options = utility2.jsonCopy(options);
      options.argv0 = utility2.__dirname + '/.install/slimerjs/slimerjs';
      utility2.headlessPhantomjs(options, onEventError);
    },

    _headlessSlimerjs_default_test: function (onEventError) {
      /*
        this function tests headlessSlimerjs's default handling behavior
      */
      utility2.headlessSlimerjs({
        timeoutDefault: state.timeoutDefault,
        url: '{{localhost}}/test/test.html?testCallbackId={{testCallbackId}}#modeTest=1'
          + '&testReportUpload=1'
      }, onEventError);
    }

  };
  local._init();
}());



(function moduleRollupNodejs() {
  /*
    this nodejs module exports the rollup api
  */
  'use strict';
  var local;
  local = {

    _name: 'utility2.moduleRollupNodejs',

    _init: function () {
      if (state.modeNodejs) {
        utility2.initLocal(local);
      }
    },

    _minifyFile: function (file, onEventError) {
      /*
        this function minifies css / js files
      */
      var mode, onEventError2;
      mode = 0;
      onEventError2 = function (error, data) {
        mode = utility2.modeIncrement(error, mode);
        switch (mode) {
        case 1:
          required.fs.readFile(file, 'utf8', onEventError2);
          break;
        case 2:
          utility2.jsonLog('_minifyFile - minifying ' + file);
          onEventError2(null, utility2.scriptMinify(file, data));
          break;
        case 3:
          utility2.fsWriteFileAtomic(file.replace((/([^.]*$)/), 'min.$1'), data, onEventError2);
          break;
        default:
          onEventError(error);
        }
      };
      onEventError2();
    },

    __minifyFile_error_test: function (onEventError) {
      /*
        this function tests _minifyFile's error handling behavior
      */
      utility2.testMock(onEventError, [
        [required, { fs: { readFile: utility2.callError2 } }]
      ], function (onEventError) {
        local._minifyFile(null, function (error) {
          utility2.tryCatch(function () {
            /* assert error occurred */
            utility2.assert(error instanceof Error, error);
            onEventError();
          }, onEventError);
        });
      });
    },

    modeCliDict_rollupFileList: function () {
      /*
        this function rolls up the specified files
      */
      state.rollupFileList.split(',').forEach(function (file) {
        local._rollupFile(file, utility2.onEventErrorDefault);
      });
    },

    _modeCliDict_rollupFileList_default_test: function (onEventError) {
      /*
        this function tests modeCliDict_rollupFileList's default handling behavior
      */
      utility2.testMock(onEventError, [
        [local, { _rollupFile: utility2.nop }],
        [state, { modeCli: 'rollupFileList', rollupFileList: 'aa,bb' }]
      ], function (onEventError) {
        local.modeCliDict_rollupFileList();
        onEventError();
      });
    },

    _rollupFile: function (file, onEventError) {
      /*
        this function rolls up a css / js file
      */
      var content, dataList, mode, onEventError2, options, onEventReady;
      mode = 0;
      onEventError2 = function (error, data) {
        mode = utility2.modeIncrement(error, mode);
        switch (mode) {
        case 1:
          utility2.jsonLog('_rollupFile - rolling up ' + file);
          required.fs.readFile(file, 'utf8', onEventError2);
          break;
        case 2:
          content = data;
          utility2.evalOnEventError(
            file,
            utility2.scriptLint(file + '.js', content
              .replace((/(^\/\* CSS_COMMENT|CSS_COMMENT \*\/$)/gm), '// $1')),
            onEventError2
          );
          break;
        case 3:
          options = data;
          dataList = utility2.jsonCopy(options.urlList);
          onEventReady = utility2.untilReady(onEventError2);
          onEventReady.remaining = dataList.length;
          utility2.ajaxMultiUrls(options, function (error, data) {
            mode = 3;
            onEventError2(error, data);
            onEventReady(error);
          });
          break;
        case 4:
          /* additional css parsing */
          if (required.path.extname(file) === '.css' && !data.modeCss) {
            data.modeCss = true;
            onEventReady.remaining += 1;
            local._rollupFileCss(data, function (error) {
              mode = 3;
              onEventError2(error, data);
              onEventReady(error);
            });
            return;
          }
          dataList[dataList.indexOf(data.options.url0)] = data;
          break;
        case 5:
          /* concat text to content */
          dataList.forEach(function (data) {
            content += '\n/* MODULE_BEGIN ' + data.options.url0 + ' */\n' + data.data.trim()
              + '\n/* MODULE_END */\n';
          });
          /* post processing */
          if (options.postProcessing) {
            content = options.postProcessing(content);
          }
          /* remove trailing whitespace */
          content = content.replace((/[\t\r ]+$/gm), '').trim() + '\n';
          /* write to file */
          file = file.replace((/([^.]*$)/), 'rollup.$1');
          utility2.fsWriteFileAtomic(file, content, onEventError2);
          break;
        case 6:
          local._minifyFile(file, onEventError2);
          break;
        default:
          onEventError(error);
        }
      };
      onEventError2();
    },

    __rollupFile_error_test: function (onEventError) {
      /*
        this function tests _rollupFile's error handling behavior
      */
      utility2.testMock(onEventError, [
        [required, { fs: { readFile: utility2.callError2 } }]
      ], function (onEventError) {
        local._rollupFile(null, function (error) {
          utility2.tryCatch(function () {
            /* assert error occurred */
            utility2.assert(error instanceof Error, error);
            onEventError();
          }, onEventError);
        });
      });
    },

    __rollupFile_jsRollup_test: function (onEventError) {
      /*
        this function tests _rollupFile's js rollup handling behavior
      */
      var file, mode, onEventError2;
      mode = 0;
      onEventError2 = function (error, data) {
        mode = utility2.modeIncrement(error, mode);
        switch (mode) {
        case 1:
          file = state.tmpdir + '/cache/' + utility2.uuid4() + '.js';
          utility2.fsWriteFileAtomic(file, '/*jslint indent: 2, regexp: true*/\n'
            + '(function () {\n'
            + '  "use strict";\n'
            + '  return { postProcessing: function (content) {\n'
            + '    return content.replace(/([;\\n]console\\.log.*)test/g, "$1test!");\n'
            + '  }, urlList: ['
            + '    "/test/test.js",\n'
            + '    "' + state.localhost + '/test/test.js"\n'
            + '    ] };\n'
            + '}());\n', onEventError2);
          break;
        case 2:
          local._rollupFile(file, onEventError2);
          break;
        case 3:
          required.fs.readFile(
            file.replace('.js', '.rollup.js'),
            'utf8',
            utility2.tryCatchHandler(onEventError2)
          );
          break;
        case 4:
          /* assert no error occurred */
          utility2.assert(!error, error);
          utility2.assert((/console\.log\('hello test!'\);/).test(data), data);
          onEventError2();
          break;
        default:
          onEventError(error);
        }
      };
      onEventError2();
    },

    _rollupFileCss: function (options, onEventError) {
      /*
        this function runs additional rollup steps for css scripts
      */
      var datauriDict, mode, onEventError2, onEventReady;
      mode = 0;
      onEventError2 = function (error, data) {
        mode = utility2.modeIncrement(error, mode);
        switch (mode) {
        case 1:
          utility2.jsonLog('_rollupFileCss - rolling up ' + options.options.url0);
          datauriDict = {};
          options.data.replace((/\burl\(([^)]+)\)/g), onEventError2);
          mode += 1;
          onEventError2();
          break;
        case 2:
          mode -= 1;
          /* ignore existing  datauri */
          if (!(/.data:./).test(data)) {
            data = required.path.resolve('/' + required.path.dirname(options.options.url0) + '/'
              + data.replace((/["']/g), '')).replace((/^\/(https*:\/)/), '$1/');
            datauriDict[data] = datauriDict[data] || {};
            datauriDict[data][error] = null;
          }
          break;
        case 3:
          onEventReady = utility2.untilReady(function (error) {
            mode = -2;
            onEventError2(error);
          });
          onEventReady.remaining += Object.keys(datauriDict).length;
          utility2.ajaxMultiUrls({
            cache: options.options.cache,
            cachePrefix: options.options.cachePrefix,
            resultType: 'binary',
            urlList: Object.keys(datauriDict)
          }, function (error, data) {
            mode = 3;
            onEventError2(error, data);
            onEventReady(error);
          });
          /* handle null case where there are no external resources to retrieve */
          onEventReady.remaining += 1;
          onEventReady();
          break;
        case 4:
          Object.keys(datauriDict[data.options.url0]).forEach(function (match) {
            options.data = options.data.replace(
              new RegExp(match.replace((/(\W)/g), '\\$1'), 'g'),
              'url(\n"data:' + utility2.mimeLookup(data.options.url0) + ';base64,'
                + data.data.toString('base64') + '"\n)'
            );
          });
          break;
        default:
          onEventError(error);
        }
      };
      onEventError2();
    },

    __rollupFileCss_default_test: function (onEventError) {
      /*
        this function tests _rollupFileCss's default handling behavior
      */
      var file, mode, onEventError2;
      mode = 0;
      onEventError2 = function (error, data) {
        mode = utility2.modeIncrement(error, mode);
        switch (mode) {
        case 1:
          file = state.tmpdir + '/cache/' + utility2.uuid4() + '.css';
          utility2.fsWriteFileAtomic(file, '/*jslint indent: 2, regexp: true*/\n'
            + '/* CSS_COMMENT\n'
            + '(function () {\n'
            + '  "use strict";\n'
            + '  return { urlList: ['
            + '    "/test/test.css",\n'
            + '    "' + state.localhost + '/test/test.css"\n'
            + '    ] };\n'
            + '}());\n'
            + 'CSS_COMMENT */\n', onEventError2);
          break;
        case 2:
          local._rollupFile(file, onEventError2);
          break;
        case 3:
          required.fs.readFile(
            file.replace('.css', '.rollup.css'),
            'utf8',
            utility2.tryCatchHandler(onEventError2)
          );
          break;
        case 4:
          /* assert no error occurred */
          utility2.assert(!error, error);
          utility2.assert(!(/test.png/).test(data), data);
          onEventError2();
          break;
        default:
          onEventError(error);
        }
      };
      onEventError2();
    },

    __rollupFileCss_error_test: function (onEventError) {
      /*
        this function tests _rollupFileCss's error handling behavior
      */
      utility2.testMock(onEventError, [
        [utility2, { ajaxMultiUrls: utility2.callError1 }]
      ], function (onEventError) {
        var onEventReady;
        onEventReady = utility2.untilReady(onEventError);
        onEventReady.remaining += 3;
        local._rollupFileCss({
          data: 'url("test.png")',
          options: { url0: '' }
        }, function (error) {
          utility2.tryCatch(function () {
            /* assert error occurred */
            utility2.assert(error instanceof Error, error);
            onEventReady();
          }, onEventReady);
        });
      });
    }

  };
  local._init();
}());



(function moduleServerNodejs() {
  /*
    this nodejs module exports the server api
  */
  'use strict';
  var local;
  local = {

    _name: 'utility2.moduleServerNodejs',

    _init: function () {
      if (required.utility2_external) {
        utility2.initLocal(local);
      }
    },

    _initOnce: function () {
      /* init middlewares */
      ['Logging', 'Main'].forEach(function (middleware) {
        /* init middleware router dict */
        state['router' + middleware + 'Dict'] = state['router' + middleware + 'Dict'] || {};
        /* init middleware */
        state['middleware' + middleware] = state['middleware' + middleware]
          || local._createMiddleware(state['router' + middleware + 'Dict']);
      });
      /* middlewareLoggingDefault */
      state.middlewareLoggingDefault = state.middlewareLoggingDefault
        || required.connect_logger('dev');
      /* init server */
      /* defer local tests until server is listening on state.serverPort */
      utility2.readyUtility2.remaining += 1;
      /* indicate server is ready */
      utility2.serverListen(utility2.readyUtility2);
    },

    'routerLoggingDict_/': function (request, response, next) {
      /*
        this function handles default logging
      */
      switch (request.urlPathNormalized) {
      /* ignore logging for these url paths */
      case '/favicon.ico':
        next();
        break;
      default:
        state.middlewareLoggingDefault(request, response, next);
      }
    },

    'routerMainDict_/': function (request, response, next) {
      /*
        this function handles the main page
      */
      if (request.urlPathNormalized === '/') {
        utility2.serverRespondFile(response, process.cwd() + '/index.html', next);
        return;
      }
      next();
    },

    'routerMainDict_/test/testReportUpload': function (request, response, next) {
      /*
        this function receives and parses uploaded test reports
      */
      var mode, onEventError2;
      mode = 0;
      onEventError2 = function (error, data) {
        mode = utility2.modeIncrement(error, mode);
        switch (mode) {
        case 1:
          utility2.streamReadAll(
            request,
            /* security - use try catch block to parse potential malformed data */
            utility2.tryCatchHandler(utility2.jsonParseHandler(onEventError2))
          );
          break;
        case 2:
          /* debug data */
          state.debugTestReportUpload = data;
          /* merge data.coverage into global.__coverage__ */
          local._coverageMerge(global.__coverage__, data.coverage || {});
          /* merge data.testReport into state.testReport */
          utility2.testReportMerge(state.testReport, data.testReport);
          /* call testCallbackId callback if it exists */
          (state.testCallbackDict[data.testCallbackId]
            || utility2.onEventErrorDefault)(
            data.testReport.testsFailed ? new Error('tests failed') : null
          );
          response.end();
          break;
        default:
          next(error);
        }
      };
      onEventError2();
    },

    '_routerMainDict_/test/testReportUpload_error_test': function (onEventError) {
      /*
        this function tests routerMainDict_/test/testReportUpload's error handling behavior
      */
      utility2.testMock(onEventError, [
        [utility2, { streamReadAll: utility2.callError1 }]
      ], function (onEventError) {
        local[
          'routerMainDict_/test/testReportUpload'
        ](null, null, function (error) {
          /* assert error occurred */
          utility2.assert(error instanceof Error, error);
          onEventError();
        });
      });
    },

    '_routerMainDict_/test/testReportUpload_testsFailed_test': function (onEventError) {
      /*
        this function tests routerMainDict_/test/testReportUpload's
        tests failed handling behavior
      */
      utility2.testMock(onEventError, [
        [global, { state: {
          debugTestReportUpload: null,
          onEventErrorDefaultIgnoreList: state.onEventErrorDefaultIgnoreList,
          testCallbackDict: {},
          testReport: {}
        } }],
        [utility2, { streamReadAll: function (_, onEventError) {
          utility2.nop(_);
          onEventError(null, JSON.stringify({ testReport: { testsFailed: 1 } }));
        } }]
      ], function (onEventError) {
        state.onEventErrorDefaultIgnoreList.push('tests failed');
        local['routerMainDict_/test/testReportUpload'](null, {
          end: onEventError
        }, onEventError);
      });
    },

    'routerMainDict_/public': function (request, response, next) {
      /*
        this function serves public files
      */
      var data;
      data = state.fsWatchDict[request.urlPathNormalized];
      data = data && data.contentBrowser;
      /* respond with in-memory cache of data if possible */
      if (data) {
        utility2.serverRespond(request, response, 200, { data: data });
        return;
      }
      /* fallback to physical file */
      utility2.serverRespondFile(response, process.cwd() + request.urlPathNormalized, next);
    },

    'routerMainDict_/test': function (request, response, next) {
      /*
        this function serves public files
      */
      var data;
      data = state.fsWatchDict[request.urlPathNormalized];
      data = data && data.contentBrowser;
      /* respond with in-memory cache of data if possible */
      if (data) {
        utility2.serverRespond(request, response, 200, { data: data });
        return;
      }
      next();
    },

    'routerMainDict_/test/test.html': function (request, response) {
      /*
        this function serves public files
      */
      utility2.serverRespond(request, response, 200, {
        data: utility2.textFormat(state.fsWatchDict['/test/test.html'].contentBrowser, {
          name: state.name,
          testModuleDict: JSON.stringify(state.testModuleDict),
          testScript: state.testScript || '/public/utility2/utility2-test.js'
        })
      });
    },

    _createMiddleware: function (routerMainDict) {
      /*
        this function creates a middleware app using the specified router dict
      */
      return function (request, response, next) {
        var mode, onEventError2, path;
        mode = 0;
        onEventError2 = function () {
          mode += 1;
          switch (mode) {
          case 1:
            /* debug request */
            state.debugServerRequest = request;
            /* debug response */
            state.debugServerResponse = response;
            /* security - validate request url path */
            if (request.urlPathNormalized) {
              onEventError2();
              return;
            }
            path = request.url;
            /* security - enforce max url length */
            if (path.length <= 4096) {
              path = (/[^#&?]*/).exec(path)[0];
              if (path
                  /* security - enforce max path length */
                  && path.length <= 256
                  /* security - disallow relative path */
                  && !(/\.\/|\.$/).test(path)) {
                /* dyanamic path handler */
                request.urlPathNormalized = required.path.resolve(path);
                /* urlParsed */
                request.urlParams = request.urlParams || utility2.urlParamsGet(request.url);
                onEventError2();
                return;
              }
            }
            next(new Error('_createMiddleware request handler - invalid url ' + path));
            break;
          case 2:
            path = request.urlPathNormalized;
            while (!(routerMainDict[path] || path === '/')) {
              path = required.path.dirname(path);
            }
            /* found a handler matching request path */
            if (routerMainDict[path]) {
              /* debug request handler */
              state.debugServerRequestHandler = routerMainDict[path];
              /* process request with error handling */
              utility2.tryCatch(onEventError2, next);
            /* else move on to next middleware */
            } else {
              next();
            }
            break;
          case 3:
            routerMainDict[path](request, response, next);
            break;
          }
        };
        onEventError2();
      };
    },

    __createMiddleware_security_test: function (onEventError) {
      /*
        this function tests _createMiddleware's security handling behavior
      */
      var onEventReady, url;
      onEventReady = utility2.untilReady(onEventError);
      /* test path overflow handling behavior */
      onEventReady.remaining += 1;
      url = '/public/' + new Buffer(4096).toString('hex');
      state.onEventErrorDefaultIgnoreList.push(
        '_createMiddleware request handler - invalid url ' + url
      );
      utility2.ajax({ url: url }, function (error) {
        utility2.tryCatch(function () {
          /* assert error occurred */
          utility2.assert(error instanceof Error, error);
          onEventReady();
        }, onEventReady);
      });
      /* test relative path handling behavior */
      onEventReady.remaining += 1;
      state.onEventErrorDefaultIgnoreList.push(
        '_createMiddleware request handler - invalid url /public/../aa'
      );
      utility2.ajax({ url: '/public/../aa' }, function (error) {
        utility2.tryCatch(function () {
          /* assert error occurred */
          utility2.assert(error instanceof Error, error);
          onEventReady();
        }, onEventReady);
      });
    },

    _coverageMerge: function (coverage1, coverage2) {
      /*
        this function merges coverage2 into coverage1
      */
      var file1, file2;
      Object.keys(coverage2).forEach(function (key) {
        file1 = coverage1[key];
        file2 = coverage2[key];
        /* security - handle malformed file2 */
        if (file1 && file2) {
          /* remove derived info */
          delete file1.l;
          Object.keys(file2.b || {}).forEach(function (key) {
            /* security - handle malformed file2.b[key] */
            if (Array.isArray(file2.b[key])) {
              file1.b[key] = file1.b[key] || [];
              file2.b[key].forEach(function (count, ii) {
                file1.b[key][ii] = file1.b[key][ii] || 0;
                file1.b[key][ii] += count;
              });
            }
          });
          Object.keys(file2.f || {}).forEach(function (key) {
            file1.f[key] = file1.f[key] || 0;
            file1.f[key] += file2.f[key];
          });
          Object.keys(file2.s || {}).forEach(function (key) {
            file1.s[key] = file1.s[key] || 0;
            file1.s[key] += file2.s[key];
          });
        }
      });
    },

    __coverageMerge_nullCase_test: function (onEventError) {
      /*
        this function tests _coverageMerge's null case handling behavior
      */
      /* test null case 1 handling behavior */
      local._coverageMerge({}, { aa: null });
      /* test null case 2 handling behavior */
      local._coverageMerge({ aa: {} }, { aa: {} });
      /* test null case 3 handling behavior */
      local._coverageMerge({ aa: {} }, { aa: { b: { bb: null } } });
      /* test null case 4 handling behavior */
      local._coverageMerge({ aa: { b: {} } }, { aa: { b: { bb: [] } } });
      onEventError();
    },

    middlewareApplication: function (request, response, next) {
      /*
        this function exports the main middleware application
      */
      var mode, onEventError2;
      mode = 0;
      onEventError2 = function (error) {
        mode = utility2.modeIncrement(error, mode);
        switch (mode) {
        case 1:
          state.middlewareLogging(request, response, onEventError2);
          break;
        case 2:
          state.middlewareMain(request, response, onEventError2);
          break;
        default:
          next(error);
        }
      };
      onEventError2();
    },

    serverListen: function (onEventListen) {
      /*
        this function makes the server listen on the specified port, if not already listening,
        and then calls the onEventListen callback
      */
      /* if already listening, then simply call onEventListen */
      if (state.serverListened || !state.serverPort) {
        onEventListen();
        return;
      }
      /* create a random port from 32768 to 65535, inclusive, as needed */
      state.serverPort = Number(state.serverPort === 'random'
        ? utility2.serverPortRandom()
        : state.serverPort);
      /* assert valid state.serverPort */
      utility2.assert(state.serverPort, 'invalid state.serverPort ' + state.serverPort);
      /* set state.server with a new http server as needed */
      state.server = state.server || required.http.createServer(function (request, response) {
        utility2.middlewareApplication(request, response, function (error) {
          utility2.serverRespond(request, response, error ? 500 : 404, { error: error });
        });
      });
      /* listen on specified port */
      utility2.jsonLog('serverListen - listening on port ' + state.serverPort);
      state.server.listen(state.serverPort, function () {
        state.localhost = state.localhost || 'http://localhost:' + state.serverPort;
        state.serverListened = true;
        /* call onEventListen */
        onEventListen();
      });
    },

    _serverListen_default_test: function (onEventError) {
      /*
        this function tests serverListen's default handling behavior
      */
      utility2.testMock(onEventError, [
        [global, { state: { server: { listen: utility2.callArg1 }, serverPort: 1 } }]
      ], function (onEventError) {
        /* test default handling behavior */
        utility2.serverListen(utility2.nop);
        /* test re-listen handling behavior */
        utility2.serverListen(utility2.nop);
        onEventError();
      });
    },

    serverPortRandom: function () {
      /*
        this function creates a random port number from 32768-65535
      */
      /*jslint bitwise: true*/
      return (Math.random() * 0xffff) | 0x8000;
    },

    serverRespond: function (request, response, statusCode, options) {
      /*
        this function handles an appropriate response for a given status code
      */
      statusCode = Number(statusCode);
      options.data = options.data
        || statusCode + ' ' + (required.http.STATUS_CODES[statusCode] || 'Unknown Status Code');
      options.headers = options.headers || {};
      switch (statusCode) {
      /* 500 internal server error */
      case 500:
        utility2.onEventErrorDefault(options.error);
        options.contentType = options.contentType || 'text/plain';
        options.data = utility2.errorStack(options.error);
        break;
      }
      options.headers['content-type'] = options.headers['content-type']
        || options.contentType
        || utility2.mimeLookup(request.urlPathNormalized)
        || 'text/plain';
      /* write headers */
      utility2.serverResponseWriteHead(response, statusCode, options.headers);
      /* assert data is a string or buffer */
      utility2.assert(
        typeof options.data === 'string' || Buffer.isBuffer(options.data),
        'invalid data type ' + typeof options.data
      );
      response.end(options.data);
    },

    _serverRespond_default_test: function (onEventError) {
      /*
        this function tests serverRespond's default handling behavior
      */
      var data, response;
      response = { end: function (_) {
        data = _;
      }, headersSent: true };
      /* test unknown status code handling behavior */
      utility2.serverRespond({}, response, 'unknown status code', {});
      utility2.assert(data === 'NaN Unknown Status Code', data);
      onEventError();
    },

    serverRespondFile: function (response, file, next) {
      /*
        this function serves static files
      */
      utility2.serverResponseWriteHead(response, null, {
        'content-type': utility2.mimeLookup(file) || 'application/octet-stream'
      });
      required.fs.createReadStream(file).on('error', function () {
        /* security - don't leak filesystem info on error */
        next();
      }).pipe(response);
    },

    serverResponseWriteHead: function (response, statusCode, headers) {
      /*
        this function sets the headers of the response object
      */
      if (!response.headersSent) {
        response.statusCode = statusCode || response.statusCode;
        Object.keys(headers).forEach(function (key) {
          response.setHeader(key, headers[key]);
        });
      }
    },

    _serverResponseWriteHead_headersSent_test: function (onEventError) {
      /*
        this function tests serverResponseWriteHead's headersSent handling behavior
      */
      utility2.serverResponseWriteHead({ headersSent: true });
      onEventError();
    }

  };
  local._init();
}());



(function moduleServerShared() {
  /*
    this shared module exports the server api
  */
  'use strict';
  var local;
  local = {

    _name: 'utility2.moduleServerShared',

    _init: function () {
      utility2.initLocal(local);
    },

    '_routerLoggingDict_/_ignoreLogging_test': function (onEventError) {
      /*
        this function tests routerLoggingDict_/'s ignore logging handling behavior
      */
      utility2.ajax({ url: '/favicon.ico' }, function () {
        onEventError();
      });
    },

    '_routerMainDict_/_default_test': function (onEventError) {
      /*
        this function tests _routerMainDict_/'s default handling behavior
      */
      utility2.ajax({ url: '/' }, onEventError);
    },

    '_routerMainDict_/public_default_test': function (onEventError) {
      /*
        this function tests routerMainDict_/public's default handling behavior
      */
      var onEventReady;
      onEventReady = utility2.untilReady(onEventError);
      onEventReady.remaining += 2;
      /* test default handling behavior */
      utility2.ajax({ url: '/public/utility2/utility2.js' }, function (error) {
        utility2.tryCatch(function () {
          /* assert no error occurred */
          utility2.assert(!error, error);
          onEventReady();
        });
      });
      /* test non-existent url handling behavior */
      utility2.ajax({ url: '/public/' + utility2.uuid4() }, function (error) {
        utility2.tryCatch(function () {
          /* assert error occurred */
          utility2.assert(error instanceof Error, error);
          onEventReady();
        });
      });
    }

  };
  local._init();
}());



(function moduleCliExportEnvNodejs() {
  /*
    this nodejs module exports the nodejs env to its parent shell process
  */
  'use strict';
  var local;
  local = {

    _name: 'utility2.moduleCliExportEnvNodejs',

    _init: function (global) {
      var envDict, tmp, value;
      if (global.utility2 && utility2.initLocal) {
        utility2.initLocal(local);
      }
      if (!state.modeModuleEval) {
        return;
      }
      envDict = { NODEJS_PROCESS_PID: process.pid };
      /* save process vars to env */
      ['argv', 'cwd', 'pid', 'platform', 'versions'].forEach(function (key) {
        value = process[key];
        /* traverse one level for sub-dict */
        if (typeof value === 'object') {
          Object.keys(value).forEach(function (key2) {
            envDict['NODEJS_PROCESS_' + key.toUpperCase() + '_' + key2.toUpperCase()]
              = String(value[key2]);
          });
        } else {
          envDict['NODEJS_PROCESS_' + key.toUpperCase()]
            /* set value to return value of function */
            = String(typeof value === 'function' ? value() : value);
        }
      });
      /* load package.json file */
      tmp = JSON.parse(
        require('fs').readFileSync(process.cwd() + '/package.json')
      );
      /* save package.json vars to env */
      Object.keys(tmp).forEach(function (key) {
        value = tmp[key];
        if (typeof value === 'string') {
          envDict['NODEJS_PACKAGE_JSON_' + key.toUpperCase()] = value;
        }
      });
      /* export env */
      process.stdout.write(Object.keys(envDict).sort().map(function (key) {
        return 'export ' + key + '=' + JSON.stringify(envDict[key]);
      }).join(' && ').replace((/`/g), "'"));
    }

  };
  local._init(global);
}());
/* MODULE_END */
